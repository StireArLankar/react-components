{"version":3,"file":"downshift.esm-cd6887ed.js","sources":["../../node_modules/react-laag/dist/react-laag.esm.js","../../node_modules/react-is/cjs/react-is.production.min.js","../../node_modules/react-is/index.js","../../node_modules/compute-scroll-into-view/dist/index.mjs","../../node_modules/downshift/dist/downshift.esm.js"],"sourcesContent":["import { useRef, useState, useMemo, useLayoutEffect, useEffect, useCallback, createElement, useContext, createContext, forwardRef } from 'react';\nimport { createPortal } from 'react-dom';\nimport warning from 'tiny-warning';\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\n/**\r\n * Utility hook to track the reference of a html-element.\r\n * It notifies the listener when a change occured, so it can act\r\n * on the change\r\n */\n\nfunction useTrackRef(onRefChange) {\n  var storedReference = useRef(null); // this is de function that actually gets passed to the `ref` prop\n  // on the html element. I.e.:\n  // <div ref={setter} />\n\n  function setter(element) {\n    if (!element || element === storedReference.current) {\n      return;\n    }\n\n    storedReference.current = element;\n    onRefChange(element);\n  }\n\n  return setter;\n}\n/**\r\n * Utility hook that stores mutable state.\r\n * Since a getter function is used, it will always return the most\r\n * up-to-date state. This is useful when you want to get certain state within\r\n * an effect, without triggering the same effect when the same state changes.\r\n * Note: may be seen as an anti-pattern.\r\n */\n\nfunction useMutableStore(initialState) {\n  var state = useRef(initialState);\n  return useMemo(function () {\n    function set(setter) {\n      if (typeof setter === \"function\") {\n        state.current = setter(state.current);\n      } else {\n        state.current = setter;\n      }\n    }\n\n    function get() {\n      return state.current;\n    }\n\n    return [get, set];\n  }, []);\n}\n/**\r\n * Utility hook that keeps track of active event listeners and how\r\n * to remove these listeners\r\n */\n\nfunction useEventSubscriptions() {\n  var subscriptions = useRef([]);\n  return useMemo(function () {\n    function hasEventSubscriptions() {\n      return subscriptions.current.length > 0;\n    }\n\n    function removeAllEventSubscriptions() {\n      for (var _iterator = _createForOfIteratorHelperLoose(subscriptions.current), _step; !(_step = _iterator()).done;) {\n        var unsubscribe = _step.value;\n        unsubscribe();\n      }\n\n      subscriptions.current = [];\n    }\n\n    function addEventSubscription(unsubscriber) {\n      subscriptions.current.push(unsubscriber);\n    }\n\n    return {\n      hasEventSubscriptions: hasEventSubscriptions,\n      removeAllEventSubscriptions: removeAllEventSubscriptions,\n      addEventSubscription: addEventSubscription\n    };\n  }, []);\n}\n/**\r\n * SSR-safe effect hook\r\n */\n\nvar useIsomorphicLayoutEffect = typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\n/**\r\n * Utility hook that tracks an state object.\r\n * If `enabled=false` it will discard changes and reset the lastState to `null`\r\n */\n\nfunction useLastState(currentState, enabled) {\n  var lastState = useRef(currentState);\n\n  if (!enabled) {\n    lastState.current = null;\n    return lastState;\n  }\n\n  lastState.current = currentState;\n  return lastState;\n}\nvar EMPTY_BOUNDS = {\n  top: 0,\n  left: 0,\n  right: 1,\n  bottom: 1,\n  width: 1,\n  height: 1\n};\n/**\r\n * @description Utility hook that lets you use the mouse-position as source of the trigger.\r\n * This is useful in scenario's like context-menu's.\r\n *\r\n * @example\r\n * ```tsx\r\n * const {\r\n *  hasMousePosition,\r\n *  resetMousePosition,\r\n *  handleMouseEvent,\r\n *  trigger\r\n *  } = useMousePositionAsTrigger();\r\n *\r\n * const { renderLayer, layerProps } = useLayer({\r\n *  isOpen: hasMousePosition,\r\n *  trigger,\r\n *  onOutsideClick: resetMousePosition\r\n * });\r\n *\r\n * return (\r\n *  <>\r\n *   {isOpen && renderLayer(<div {...layerProps} />)}\r\n *   <div onContextMenu={handleMouseEvent} />\r\n *  </>\r\n * );\r\n * ```\r\n */\n\nfunction useMousePositionAsTrigger(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$enabled = _ref.enabled,\n      enabled = _ref$enabled === void 0 ? true : _ref$enabled,\n      _ref$preventDefault = _ref.preventDefault,\n      preventDefault = _ref$preventDefault === void 0 ? true : _ref$preventDefault;\n\n  var parentRef = useRef(null);\n\n  var _useState = useState(EMPTY_BOUNDS),\n      mouseBounds = _useState[0],\n      setMouseBounds = _useState[1];\n\n  function resetMousePosition() {\n    setMouseBounds(EMPTY_BOUNDS);\n  }\n\n  var hasMousePosition = mouseBounds !== EMPTY_BOUNDS;\n\n  function handleMouseEvent(evt) {\n    if (!enabled) {\n      return;\n    }\n\n    if (preventDefault) {\n      evt.preventDefault();\n    }\n\n    var left = evt.clientX,\n        top = evt.clientY;\n    setMouseBounds({\n      top: top,\n      left: left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      bottom: top + 1\n    });\n  }\n\n  return {\n    hasMousePosition: hasMousePosition,\n    resetMousePosition: resetMousePosition,\n    handleMouseEvent: handleMouseEvent,\n    trigger: {\n      getBounds: function getBounds() {\n        return mouseBounds;\n      },\n      getParent: parentRef.current ? function () {\n        return parentRef.current;\n      } : undefined\n    },\n    parentRef: parentRef\n  };\n}\n\n/**\r\n * Convert a pixel value into a numeric value\r\n * @param value string value (ie. '12px')\r\n */\nfunction getPixelValue(value) {\n  return parseFloat(value.replace(\"px\", \"\"));\n}\n/**\r\n * Returns a numeric value that doesn't exceed min or max\r\n */\n\nfunction limit(value, min, max) {\n  return value < min ? min : value > max ? max : value;\n}\n/**\r\n * Utility function which ensures whether a value is truthy\r\n */\n\nfunction isSet(value) {\n  return value === null || value === undefined ? false : true;\n}\n/**\r\n * Utility function that let's you assign multiple references to a 'ref' prop\r\n * @param refs list of MutableRefObject's and / or callbacks\r\n */\n\nfunction mergeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return function (element) {\n    for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done;) {\n      var ref = _step.value;\n\n      if (!ref) {\n        continue;\n      }\n\n      if (typeof ref === \"function\") {\n        ref(element);\n      } else {\n        ref.current = element;\n      }\n    }\n  };\n}\n\n/**\r\n * Utility to get the correct ResizeObserver class\r\n */\n\nfunction getResizeObserver(environment, polyfill) {\n  if (typeof environment === \"undefined\") {\n    return undefined;\n  }\n\n  return polyfill || environment.ResizeObserver;\n}\n/**\r\n * Utility function that given a element traverses up in the html-hierarchy\r\n * to find and return all ancestors that have scroll behavior\r\n */\n\nfunction findScrollContainers(element, environment) {\n  var result = [];\n\n  if (!element || !environment || element === document.body) {\n    return result;\n  }\n\n  var _environment$getCompu = environment.getComputedStyle(element),\n      overflow = _environment$getCompu.overflow,\n      overflowX = _environment$getCompu.overflowX,\n      overflowY = _environment$getCompu.overflowY;\n\n  if ([overflow, overflowX, overflowY].some(function (prop) {\n    return [\"auto\", \"scroll\"].includes(prop);\n  })) {\n    result.push(element);\n  }\n\n  return [].concat(result, findScrollContainers(element.parentElement, environment));\n}\n\nfunction createReferenceError(subject) {\n  return \"react-laag: Could not find a valid reference for the \" + subject + \" element. There might be 2 causes:\\n   - Make sure that the 'ref' is set correctly on the \" + subject + \" element when isOpen: true. Also make sure your component forwards the ref with \\\"forwardRef()\\\".\\n   - Make sure that you are actually rendering the \" + subject + \" when the isOpen prop is set to true\";\n}\n/**\r\n * This hook has the responsibility to track the bounds of:\r\n * - the trigger element\r\n * - the layer element\r\n * - the arrow element\r\n * - the scroll-containers of which the trigger element is a descendant of\r\n *\r\n * It will call the `onChange` callback with a collection of these elements when any\r\n * of the tracked elements bounds have changed\r\n *\r\n * It will detect these changes by listening:\r\n * - when the reference of the trigger element changes\r\n * - when the reference of the layer element changes\r\n * - when the trigger, layer or document body changes in size\r\n * - when the user scrolls the page, or any of the scroll containers\r\n */\n\n\nfunction useTrackElements(_ref) {\n  var enabled = _ref.enabled,\n      onChange = _ref.onChange,\n      environment = _ref.environment,\n      ResizeObserverPolyfill = _ref.ResizeObserverPolyfill,\n      overflowContainer = _ref.overflowContainer,\n      triggerOption = _ref.triggerOption;\n  // get the correct reference to the ResizeObserver class\n  var ResizeObserver = getResizeObserver(environment, ResizeObserverPolyfill); // warn the user when no valid ResizeObserver class could be found\n\n  useEffect(function () {\n    process.env.NODE_ENV !== \"production\" ? warning(ResizeObserver, \"This browser does not support ResizeObserver out of the box. We recommend to add a polyfill in order to utilize the full capabilities of react-laag. See: https://github.com/everweij/react-laag#resize-observer\") : void 0;\n  }, [ResizeObserver]); // keep reference of the optional arrow-component\n\n  var arrowRef = useRef(null); // if user has provided the trigger-option we should ingore certain things elsewhere\n\n  var hasTriggerOption = Boolean(triggerOption); // Keep track of mutable element related state\n  // It is generally better to use React.useState, but unfortunately that causes to many re-renders\n\n  var _useMutableStore = useMutableStore({\n    scrollContainers: [],\n    trigger: null,\n    layer: null\n  }),\n      get = _useMutableStore[0],\n      set = _useMutableStore[1]; // utility to keep track of the scroll and resize listeners and how to unsubscribe them\n\n\n  var _useEventSubscription = useEventSubscriptions(),\n      hasEventSubscriptions = _useEventSubscription.hasEventSubscriptions,\n      addEventSubscription = _useEventSubscription.addEventSubscription,\n      removeAllEventSubscriptions = _useEventSubscription.removeAllEventSubscriptions; // All scroll and resize changes eventually end up here, where the collection of bounds (subjectsBounds) is\n  // constructed in order to notifiy the `onBoundsChange` callback\n\n\n  var handleChange = useCallback(function handleChange() {\n    var _get = get(),\n        layer = _get.layer,\n        trigger = _get.trigger,\n        scrollContainers = _get.scrollContainers;\n\n    var closestScrollContainer = scrollContainers[0];\n\n    if (!layer) {\n      throw new Error(createReferenceError(\"layer\"));\n    } // ignore when user has provided the trigger-option\n\n\n    if (!trigger && !hasTriggerOption) {\n      throw new Error(createReferenceError(\"trigger\"));\n    }\n\n    var scrollOffsets = {\n      top: 0,\n      left: 0\n    };\n\n    if (closestScrollContainer) {\n      var scrollLeft = closestScrollContainer.scrollLeft,\n          scrollTop = closestScrollContainer.scrollTop;\n      scrollOffsets = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n    } else {\n      var scrollX = environment.scrollX,\n          scrollY = environment.scrollY;\n      scrollOffsets = {\n        top: scrollY,\n        left: scrollX\n      };\n    }\n\n    var borderOffsets = {\n      left: 0,\n      top: 0\n    };\n\n    if (closestScrollContainer) {\n      var _environment$getCompu2 = environment.getComputedStyle(closestScrollContainer),\n          borderLeftWidth = _environment$getCompu2.borderLeftWidth,\n          borderTopWidth = _environment$getCompu2.borderTopWidth;\n\n      borderOffsets = {\n        left: getPixelValue(borderLeftWidth) || 0,\n        top: getPixelValue(borderTopWidth) || 0\n      };\n    }\n\n    onChange({\n      layer: layer,\n      trigger: trigger,\n      scrollContainers: scrollContainers,\n      arrow: arrowRef.current\n    }, scrollOffsets, borderOffsets);\n  }, [get, onChange, environment, arrowRef, hasTriggerOption]); // responsible for adding the scroll and resize listeners to the correct\n  // html elements\n\n  var addEventListeners = useCallback(function addEventListeners() {\n    var _get2 = get(),\n        trigger = _get2.trigger,\n        layer = _get2.layer,\n        scrollContainers = _get2.scrollContainers;\n\n    if (!layer) {\n      throw new Error(createReferenceError(\"layer\"));\n    }\n\n    if (!trigger && !hasTriggerOption) {\n      // ignore when user has provided the trigger-option\n      throw new Error(createReferenceError(\"trigger\"));\n    }\n\n    if (ResizeObserver) {\n      var ignoredInitialCall = false;\n\n      var observerCallback = function observerCallback() {\n        if (!ignoredInitialCall) {\n          ignoredInitialCall = true;\n          return;\n        }\n\n        handleChange();\n      };\n\n      var observer = new ResizeObserver(observerCallback);\n\n      for (var _i = 0, _arr = [trigger, layer, document.body]; _i < _arr.length; _i++) {\n        var element = _arr[_i];\n        if (element) observer.observe(element);\n      }\n\n      addEventSubscription(function () {\n        for (var _i2 = 0, _arr2 = [trigger, layer, document.body]; _i2 < _arr2.length; _i2++) {\n          var _element = _arr2[_i2];\n          if (_element) observer.unobserve(_element);\n        }\n\n        observer.disconnect();\n      });\n    }\n\n    var listenForScrollElements = [environment].concat(scrollContainers);\n\n    var _loop = function _loop() {\n      var element = _step.value;\n      element.addEventListener(\"scroll\", handleChange);\n      addEventSubscription(function () {\n        return element.removeEventListener(\"scroll\", handleChange);\n      });\n    };\n\n    for (var _iterator = _createForOfIteratorHelperLoose(listenForScrollElements), _step; !(_step = _iterator()).done;) {\n      _loop();\n    }\n  }, [get, addEventSubscription, handleChange, environment, ResizeObserver, hasTriggerOption]); // when either the reference to the trigger or layer element changes\n  // we should reset the event listeners and trigger a `onChange`\n\n  var resetWhenReferenceChangedWhileTracking = useCallback(function (previous, next) {\n    if (enabled && previous && previous !== next) {\n      removeAllEventSubscriptions();\n      addEventListeners();\n      handleChange();\n    }\n  }, [removeAllEventSubscriptions, addEventListeners, handleChange, enabled]); // Logic when reference to layer changes\n\n  var layerRef = useTrackRef(useCallback(function (layer) {\n    var _get3 = get(),\n        previousLayer = _get3.layer; // store new reference\n\n\n    set(function (state) {\n      return _extends({}, state, {\n        layer: layer\n      });\n    }); // check if we should reset the event listeners\n\n    resetWhenReferenceChangedWhileTracking(previousLayer, layer);\n  }, [get, set, resetWhenReferenceChangedWhileTracking]));\n  var getScrollContainers = useCallback(function handleScrollContainers(element) {\n    var scrollContainers = findScrollContainers(element, environment);\n    var closestScrollContainer = scrollContainers[0];\n\n    if (closestScrollContainer) {\n      // Check if we should warn the user about 'position: relative; stuff...'\n      var position = environment.getComputedStyle(closestScrollContainer).position;\n      var closestScrollContainerHasCorrectStyling = [\"relative\", \"absolute\", \"fixed\"].includes(position) || overflowContainer;\n\n      if (!closestScrollContainerHasCorrectStyling) {\n        closestScrollContainer.style.position = \"relative\";\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(closestScrollContainerHasCorrectStyling, \"react-laag: Set the 'position' style of the nearest scroll-container to 'relative', 'absolute' or 'fixed', or set the 'overflowContainer' prop to true. This is needed in order to position the layer properly. Currently the scroll-container is positioned: \\\"\" + position + \"\\\". For now, \\\"position: relative;\\\" is added for you, but this behavior might be removed in the future. Visit https://react-laag.com/docs/#position-relative for more info.\") : void 0;\n    }\n\n    return scrollContainers;\n  }, [environment, overflowContainer]); // Logic when reference to trigger changes\n  // Note: this will have no effect when user provided the trigger-option\n\n  var triggerRef = useTrackRef(useCallback(function (trigger) {\n    // collect list of scroll containers\n    var scrollContainers = getScrollContainers(trigger);\n\n    var _get4 = get(),\n        previousTrigger = _get4.trigger; // store new references\n\n\n    set(function (state) {\n      return _extends({}, state, {\n        trigger: trigger,\n        scrollContainers: scrollContainers\n      });\n    }); // check if we should reset the event listeners\n\n    resetWhenReferenceChangedWhileTracking(previousTrigger, trigger);\n  }, [get, set, resetWhenReferenceChangedWhileTracking, getScrollContainers])); // when user has provided the trigger-option, it monitors the optional parent-element\n  // in order to determine the scroll-containers\n\n  var triggerOptionParent = triggerOption == null ? void 0 : triggerOption.getParent == null ? void 0 : triggerOption.getParent();\n  useIsomorphicLayoutEffect(function () {\n    if (!triggerOptionParent) {\n      return;\n    }\n\n    set(function (state) {\n      return _extends({}, state, {\n        scrollContainers: getScrollContainers(triggerOptionParent)\n      });\n    });\n  }, [triggerOptionParent, set, getScrollContainers]);\n  useIsomorphicLayoutEffect(function () {\n    if (enabled) {\n      // add event listeners if necessary\n      if (!hasEventSubscriptions()) {\n        addEventListeners();\n      }\n    }\n\n    return function () {\n      if (hasEventSubscriptions()) {\n        removeAllEventSubscriptions();\n      }\n    };\n  }, [enabled, hasEventSubscriptions, addEventListeners, removeAllEventSubscriptions]); // run this effect after every render\n\n  useIsomorphicLayoutEffect(function () {\n    if (enabled) {\n      // eventually call `handleChange` with latest elements-refs\n      handleChange();\n    }\n  });\n  return {\n    triggerRef: triggerRef,\n    layerRef: layerRef,\n    arrowRef: arrowRef,\n    closestScrollContainer: get().scrollContainers[0] || null\n  };\n}\n\nvar GroupContext = /*#__PURE__*/createContext({}); // Provider that wraps arround the layer in order to provide other useLayers\n// down in the hiearchy (child layers) with means to communicate with the parent.\n// This provider receives a `registrations` Set which can be used to add and\n// delete registrations.\n\nfunction GroupProvider(_ref) {\n  var children = _ref.children,\n      registrations = _ref.registrations;\n  // registration function that is used as 'context payload' for child layers\n  // to call. It returns a function to unregister.\n  var handleRegister = useCallback(function register(registration) {\n    registrations.current.add(registration);\n    return function () {\n      return registrations.current.delete(registration);\n    };\n  }, [registrations]);\n  return createElement(GroupContext.Provider, {\n    value: handleRegister\n  }, children);\n} // asks child layers if they would close given the documents click event\n// if there's one that signals not to close, return early (false)\n\nfunction getShouldCloseAccordingToChildren(registrations, event) {\n  for (var _iterator = _createForOfIteratorHelperLoose(registrations), _step; !(_step = _iterator()).done;) {\n    var shouldCloseWhenClickedOutside = _step.value.shouldCloseWhenClickedOutside;\n\n    if (!shouldCloseWhenClickedOutside(event)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * Responsible for close behavior\r\n * When the `onOutsideClick` callback is provided by the user, it will listen for clicks\r\n * in the document, and tell whether the user clicked outside -> not on layer / trigger.\r\n * It keeps track of nested useLayers a.k.a child layers (`registrations` Set), through which\r\n * we can ask whether they `shouldCloseWhenClickedOutside`, or tell them to close.\r\n *\r\n * Behavior:\r\n * - `onOutsideClick` only works on the most outer parent, and not on children. The parent will ask\r\n *   the child layers whether they would close, and will handle accordingly. The parent may\r\n *   command the children to close indirectly with the help of `onParentClose`\r\n * - When the parent just was closed, it will make sure that any children will also close\r\n *   with the help of `onParentClose`\r\n */\n\n\nfunction useGroup(_ref2) {\n  var isOpen = _ref2.isOpen,\n      onOutsideClick = _ref2.onOutsideClick,\n      onParentClose = _ref2.onParentClose;\n  // store references to the dom-elements\n  // we need these to later determine wether the clicked outside or not\n  var trigger = useRef(null);\n  var layer = useRef(null); // a Set which keeps track of callbacks given by the child layers through context\n\n  var registrations = useRef(new Set()); // if this instance is a child itself, we should use this function to register\n  // some callbacks to the parent\n\n  var possibleRegisterFn = useContext(GroupContext); // recursively checks whether to close or not. This mechanism has some similarities\n  // with event bubbling.\n\n  var shouldCloseWhenClickedOutside = useCallback(function shouldCloseWhenClickedOutside(event) {\n    var target = event.target;\n    var clickedOnTrigger = trigger.current && trigger.current.contains(target);\n    var clickedOnLayer = layer.current && layer.current.contains(target);\n    var shouldCloseAccordingToChildren = getShouldCloseAccordingToChildren(registrations.current, event); // when clicked on own layer, but the child would have closed ->\n    // let child close\n\n    if (clickedOnLayer && shouldCloseAccordingToChildren) {\n      registrations.current.forEach(function (_ref3) {\n        var closeChild = _ref3.closeChild;\n        return closeChild();\n      });\n    }\n\n    return !clickedOnTrigger && !clickedOnLayer && shouldCloseAccordingToChildren;\n  }, [trigger, layer, registrations]); // registration stuff\n\n  useEffect(function () {\n    if (typeof possibleRegisterFn !== \"function\") {\n      return;\n    } // 'possibleRegisterFn' will return a function that will unregister\n    // on cleanup\n\n\n    return possibleRegisterFn({\n      shouldCloseWhenClickedOutside: shouldCloseWhenClickedOutside,\n      closeChild: function closeChild() {\n        process.env.NODE_ENV !== \"production\" ? warning(onParentClose, \"react-laag: You are using useLayer() in a nested setting but forgot to set the 'onParentClose()' callback in the options. This could lead to unexpected behavior.\") : void 0;\n\n        if (onParentClose) {\n          onParentClose();\n        }\n      }\n    });\n  }, [possibleRegisterFn, shouldCloseWhenClickedOutside, onParentClose, registrations]); // document click handling\n\n  useEffect(function () {\n    var isChild = typeof possibleRegisterFn === \"function\";\n    var shouldNotListen = !isOpen || !onOutsideClick || isChild;\n\n    if (shouldNotListen) {\n      return;\n    }\n\n    function handleClick(event) {\n      if (shouldCloseWhenClickedOutside(event)) {\n        onOutsideClick();\n      }\n    }\n\n    document.addEventListener(\"click\", handleClick, true);\n    return function () {\n      return document.removeEventListener(\"click\", handleClick, true);\n    };\n  }, [isOpen, onOutsideClick, shouldCloseWhenClickedOutside, possibleRegisterFn]); // When this 'useLayer' gets closed -> tell child layers to close as well\n\n  useEffect(function () {\n    if (!isOpen) {\n      registrations.current.forEach(function (_ref4) {\n        var closeChild = _ref4.closeChild;\n        return closeChild();\n      });\n    }\n  }, [isOpen]);\n  return {\n    closeOnOutsideClickRefs: {\n      trigger: trigger,\n      layer: layer\n    },\n    registrations: registrations\n  };\n}\n\nvar PLACEMENT_TYPES = [\"bottom-start\", \"bottom-end\", \"bottom-center\", \"top-start\", \"top-center\", \"top-end\", \"left-end\", \"left-center\", \"left-start\", \"right-end\", \"right-center\", \"right-start\", \"center\"];\n\nvar OPPOSITES = {\n  top: \"bottom\",\n  left: \"right\",\n  bottom: \"top\",\n  right: \"left\",\n  center: \"center\"\n};\n\nvar SideBase = /*#__PURE__*/function () {\n  function SideBase(prop, opposite, isHorizontal, sizeProp, oppositeSizeProp, cssProp, oppositeCssProp, isCenter, isPush // left | top\n  ) {\n    this.prop = void 0;\n    this.opposite = void 0;\n    this.isHorizontal = void 0;\n    this.sizeProp = void 0;\n    this.oppositeSizeProp = void 0;\n    this.cssProp = void 0;\n    this.oppositeCssProp = void 0;\n    this.isCenter = void 0;\n    this.isPush = void 0;\n    this.prop = prop;\n    this.opposite = opposite;\n    this.isHorizontal = isHorizontal;\n    this.sizeProp = sizeProp;\n    this.oppositeSizeProp = oppositeSizeProp;\n    this.cssProp = cssProp;\n    this.oppositeCssProp = oppositeCssProp;\n    this.isCenter = isCenter;\n    this.isPush = isPush;\n  }\n\n  var _proto = SideBase.prototype;\n\n  _proto.factor = function factor(value) {\n    return value * (this.isPush ? 1 : -1);\n  };\n\n  _proto.isOppositeDirection = function isOppositeDirection(side) {\n    return this.isHorizontal !== side.isHorizontal;\n  };\n\n  return SideBase;\n}();\n\nfunction createSide(prop, recursive) {\n  if (recursive === void 0) {\n    recursive = true;\n  }\n\n  var isHorizontal = [\"left\", \"right\"].includes(prop);\n  return new SideBase(prop, recursive ? createSide(OPPOSITES[prop], false) : null, isHorizontal, isHorizontal ? \"width\" : \"height\", isHorizontal ? \"height\" : \"width\", isHorizontal ? \"left\" : \"top\", isHorizontal ? \"top\" : \"left\", prop === \"center\", ![\"right\", \"bottom\"].includes(prop));\n}\n\nvar BoundSide = {\n  top: /*#__PURE__*/createSide(\"top\"),\n  bottom: /*#__PURE__*/createSide(\"bottom\"),\n  left: /*#__PURE__*/createSide(\"left\"),\n  right: /*#__PURE__*/createSide(\"right\")\n};\nvar Side = /*#__PURE__*/_extends({}, BoundSide, {\n  center: /*#__PURE__*/createSide(\"center\")\n});\n\nvar SIDES = [\"top\", \"left\", \"bottom\", \"right\"];\n/**\r\n * A class containing the positional properties which represent the distance\r\n * between two Bounds instances for each side\r\n */\n\nvar BoundsOffsets = /*#__PURE__*/function () {\n  function BoundsOffsets(offsets) {\n    this.top = void 0;\n    this.left = void 0;\n    this.right = void 0;\n    this.bottom = void 0;\n    return Object.assign(this, offsets);\n  }\n  /**\r\n   * Takes multiple BoundsOffets instances and creates a new BoundsOffsets instance\r\n   * by taking the smallest value for each side\r\n   * @param boundsOffsets list of BoundsOffsets instances\r\n   */\n\n\n  BoundsOffsets.mergeSmallestSides = function mergeSmallestSides(boundsOffsets) {\n    var first = boundsOffsets[0],\n        rest = boundsOffsets.slice(1);\n\n    if (!first) {\n      throw new Error(\"Please provide at least 1 bounds objects in order to merge\");\n    }\n\n    var result = Object.fromEntries(SIDES.map(function (side) {\n      return [side, first[side]];\n    }));\n\n    for (var _iterator = _createForOfIteratorHelperLoose(rest), _step; !(_step = _iterator()).done;) {\n      var boundsOffset = _step.value;\n\n      for (var _iterator2 = _createForOfIteratorHelperLoose(SIDES), _step2; !(_step2 = _iterator2()).done;) {\n        var side = _step2.value;\n        result[side] = Math.min(result[side], boundsOffset[side]);\n      }\n    }\n\n    return new BoundsOffsets(result);\n  }\n  /**\r\n   * Checks whether all sides sides are positive, meaning the corresponding Bounds instance\r\n   * fits perfectly within a parent Bounds instance\r\n   */\n  ;\n\n  _createClass(BoundsOffsets, [{\n    key: \"allSidesArePositive\",\n    get: function get() {\n      var _this = this;\n\n      return SIDES.every(function (side) {\n        return _this[side] >= 0;\n      });\n    }\n    /**\r\n     * Returns a partial IBoundsOffsets with sides that are negative, meaning sides aren't entirely\r\n     * visible in respect to a parent Bounds instance\r\n     */\n\n  }, {\n    key: \"negativeSides\",\n    get: function get() {\n      var _this2 = this;\n\n      return Object.fromEntries(SIDES.filter(function (side) {\n        return _this2[side] < 0;\n      }).map(function (side) {\n        return [side, _this2[side]];\n      }));\n    }\n  }]);\n\n  return BoundsOffsets;\n}();\n\n/**\r\n * Utility function that returns sum of various computed styles\r\n * @param propertyValues list of computed styles (ie. '12px')\r\n */\n\nfunction sumOfPropertyValues() {\n  for (var _len = arguments.length, propertyValues = new Array(_len), _key = 0; _key < _len; _key++) {\n    propertyValues[_key] = arguments[_key];\n  }\n\n  return propertyValues.reduce(function (sum, propertyValue) {\n    return sum + (propertyValue ? getPixelValue(propertyValue) : 0);\n  }, 0);\n}\n\nfunction boundsToObject(_ref) {\n  var top = _ref.top,\n      left = _ref.left,\n      right = _ref.right,\n      bottom = _ref.bottom,\n      width = _ref.width,\n      height = _ref.height;\n  return {\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom,\n    width: width,\n    height: height\n  };\n}\nvar EMPTY = {\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0,\n  width: 0,\n  height: 0\n};\n/**\r\n * A class containing the positional properties of the native DOM's ClientRect\r\n * (`element.getBoundingClientRect()`), together with some utility methods\r\n */\n\nvar Bounds = /*#__PURE__*/function () {\n  /**\r\n   * Creates a new Bounds class\r\n   * @param bounds An object that adheres to the `IBounds` interface\r\n   */\n  Bounds.create = function create(bounds) {\n    return new Bounds(bounds);\n  }\n  /**\r\n   * Creates a new Bounds class from a DOM-element\r\n   * @param element reference to the DOM-element\r\n   * @param options optional options object\r\n   */\n  ;\n\n  Bounds.fromElement = function fromElement(element, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        _options$withTransfor = _options.withTransform,\n        withTransform = _options$withTransfor === void 0 ? true : _options$withTransfor,\n        _options$environment = _options.environment,\n        environment = _options$environment === void 0 ? window : _options$environment,\n        _options$withScrollba = _options.withScrollbars,\n        withScrollbars = _options$withScrollba === void 0 ? true : _options$withScrollba;\n    var plain = boundsToObject(element.getBoundingClientRect());\n    var bounds = new Bounds(plain);\n\n    if (!withTransform) {\n      var _environment$getCompu = environment.getComputedStyle(element),\n          width = _environment$getCompu.width,\n          height = _environment$getCompu.height,\n          boxSizing = _environment$getCompu.boxSizing,\n          borderLeft = _environment$getCompu.borderLeft,\n          borderRight = _environment$getCompu.borderRight,\n          borderTop = _environment$getCompu.borderTop,\n          borderBottom = _environment$getCompu.borderBottom,\n          paddingLeft = _environment$getCompu.paddingLeft,\n          paddingRight = _environment$getCompu.paddingRight,\n          paddingTop = _environment$getCompu.paddingTop,\n          paddingBottom = _environment$getCompu.paddingBottom;\n\n      var boxWidth = boxSizing === \"border-box\" ? getPixelValue(width) : sumOfPropertyValues(width, borderLeft, borderRight, paddingLeft, paddingRight);\n      var boxHeight = boxSizing === \"border-box\" ? getPixelValue(height) : sumOfPropertyValues(height, borderTop, borderBottom, paddingTop, paddingBottom);\n      bounds = new Bounds(_extends({}, bounds, {\n        width: boxWidth,\n        height: boxHeight\n      }));\n    }\n\n    if (!withScrollbars) {\n      var scrollbarWidth = bounds.width - element.clientWidth;\n      var scrollbarHeight = bounds.height - element.clientHeight;\n      return bounds.substract({\n        right: scrollbarWidth,\n        bottom: scrollbarHeight\n      });\n    }\n\n    return bounds;\n  }\n  /**\r\n   * Creates an empty Bounds class\r\n   */\n  ;\n\n  Bounds.empty = function empty() {\n    return new Bounds();\n  }\n  /**\r\n   * Creates a Bounds class from the window's dimensions\r\n   * @param environment reference to the window-object (needed when working with iframes for instance). Defaults to `window`\r\n   */\n  ;\n\n  Bounds.fromWindow = function fromWindow(environment) {\n    var _environment$document;\n\n    var scrollingElement = (_environment$document = environment == null ? void 0 : environment.document.scrollingElement) != null ? _environment$document : environment == null ? void 0 : environment.document.documentElement;\n\n    var _ref2 = scrollingElement != null ? scrollingElement : {},\n        _ref2$clientWidth = _ref2.clientWidth,\n        width = _ref2$clientWidth === void 0 ? 0 : _ref2$clientWidth,\n        _ref2$clientHeight = _ref2.clientHeight,\n        height = _ref2$clientHeight === void 0 ? 0 : _ref2$clientHeight;\n\n    return new Bounds({\n      width: width,\n      height: height,\n      right: width,\n      bottom: height\n    });\n  };\n\n  function Bounds(bounds) {\n    if (bounds === void 0) {\n      bounds = {};\n    }\n\n    this.top = void 0;\n    this.left = void 0;\n    this.right = void 0;\n    this.bottom = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    return Object.assign(this, EMPTY, bounds);\n  }\n  /**\r\n   * Returns the square surface of the bounds in pixels\r\n   */\n\n\n  var _proto = Bounds.prototype;\n\n  /**\r\n   * Returns a plain object containing only positional properties\r\n   */\n  _proto.toObject = function toObject() {\n    return boundsToObject(this);\n  };\n\n  _proto.merge = function merge(partialBoundsOrMergeFn) {\n    var current = this.toObject();\n    return new Bounds(_extends({}, current, typeof partialBoundsOrMergeFn === \"function\" ? partialBoundsOrMergeFn(current) : partialBoundsOrMergeFn));\n  }\n  /**\r\n   * Return a new Bounds instance by subtracting each property of the provided IBounds object\r\n   * @param bounds partial IBounds object to substract with\r\n   */\n  ;\n\n  _proto.substract = function substract(bounds) {\n    var result = this.toObject();\n    var entries = Object.entries(bounds);\n\n    for (var _i = 0, _entries = entries; _i < _entries.length; _i++) {\n      var _entries$_i = _entries[_i],\n          prop = _entries$_i[0],\n          value = _entries$_i[1];\n\n      if (prop in BoundSide) {\n        // if `prop` is one of 'top', 'left', 'bottom' or 'right'...\n        var boundSide = BoundSide[prop]; // decide if we should add or substract\n\n        result[prop] += boundSide.factor(value); // make sure that the size-properties are also updated\n\n        result[boundSide.isHorizontal ? \"width\" : \"height\"] -= value;\n      } else {\n        // prop is 'width' or 'height'\n        result[prop] -= value || 0;\n      }\n    }\n\n    return new Bounds(result);\n  }\n  /**\r\n   * Returns a new BoundsOffsets instance by determining the distance for each bound-side:\r\n   * (child -> parent)\r\n   * @param child child bounds instance\r\n   */\n  ;\n\n  _proto.offsetsTo = function offsetsTo(child) {\n    return new BoundsOffsets({\n      top: child.top - this.top,\n      bottom: this.bottom - child.bottom,\n      left: child.left - this.left,\n      right: this.right - child.right\n    });\n  }\n  /**\r\n   * Return a new Bounds instance by mapping over each bound-side\r\n   * @param mapper callback that takes a boundSide + value in pixels, returning a new value for that side\r\n   */\n  ;\n\n  _proto.mapSides = function mapSides(mapper) {\n    var result = this.toObject();\n    var boundSides = Object.values(BoundSide);\n\n    for (var _i2 = 0, _boundSides = boundSides; _i2 < _boundSides.length; _i2++) {\n      var boundSide = _boundSides[_i2];\n      result[boundSide.prop] = mapper(boundSide, result[boundSide.prop]);\n    }\n\n    return new Bounds(result);\n  };\n\n  _createClass(Bounds, [{\n    key: \"surface\",\n    get: function get() {\n      return this.width * this.height;\n    }\n  }]);\n\n  return Bounds;\n}();\n\n/**\r\n * Class for various calculations based on a placement-type. I.e 'top-left';\r\n */\n\nvar Placement = /*#__PURE__*/function () {\n  function Placement(primary, secondary, subjectBounds, layerDimensions, offsets) {\n    this.primary = void 0;\n    this.secondary = void 0;\n    this.offsets = void 0;\n    this.subjectsBounds = void 0;\n    this._cachedLayerBounds = null;\n    this._cachedContainerOffsets = null;\n    this.primary = primary;\n    this.secondary = secondary;\n    this.offsets = offsets;\n    this.setSubjectsBounds(subjectBounds, layerDimensions);\n  }\n  /**\r\n   * Set subjectsBounds that are specific for this placement\r\n   * @param subjectBounds original SubjectBounds instance\r\n   * @param layerDimensions possible config prodvided by the user\r\n   */\n\n\n  var _proto = Placement.prototype;\n\n  _proto.setSubjectsBounds = function setSubjectsBounds(subjectBounds, layerDimensions) {\n    // if user did not provide any layerDimensions config...\n    if (!layerDimensions) {\n      this.subjectsBounds = subjectBounds;\n      return;\n    } // get anticipated layer-dimensions provided by the user\n\n\n    var dimensions = // if the user passed a callback, call it with the layerSide corresponding to\n    // the placement\n    typeof layerDimensions === \"function\" ? layerDimensions(this.primary.prop) : layerDimensions; // create new SubjectsBounds instance by merging our newly create layer-bounds\n\n    this.subjectsBounds = subjectBounds.merge({\n      layer: _extends({}, subjectBounds.layer, dimensions)\n    });\n  }\n  /**\r\n   * Returns the string respresentation of this placement (ie. 'top-start')\r\n   */\n  ;\n\n  /**\r\n   * Calculates the actual boundaries based on the placement\r\n   * @param secondaryOffset optional offset on the secondary-side\r\n   */\n  _proto.getLayerBounds = function getLayerBounds(secondaryOffset) {\n    if (secondaryOffset === void 0) {\n      secondaryOffset = 0;\n    }\n\n    // return cached version if possible\n    if (this._cachedLayerBounds && secondaryOffset === 0) {\n      return this._cachedLayerBounds;\n    }\n\n    var primary = this.primary,\n        secondary = this.secondary,\n        subjectsBounds = this.subjectsBounds;\n    var trigger = subjectsBounds.trigger,\n        layer = subjectsBounds.layer,\n        arrow = subjectsBounds.arrow;\n    var isHorizontal = primary.isHorizontal,\n        oppositeCssProp = primary.oppositeCssProp,\n        oppositeSizeProp = primary.oppositeSizeProp,\n        prop = primary.prop,\n        opposite = primary.opposite;\n    var result = Bounds.empty(); // let's take the placement 'top-start' as an example...\n    // the offsets are the following:\n    // trigger -> 8px\n    // container -> 10px;\n    // arrow -> 2px;\n    // PRIMARY STUFF\n    // bottom = trigger.top + 8;\n\n    result[opposite.prop] = trigger[prop] - primary.factor(this.offsets.trigger); // top = bottom - layer.height\n\n    result[prop] = result[opposite.prop] - primary.factor(layer[primary.sizeProp]); // SECONDARY STUFF\n    // arrowOffsetBase = 4\n\n    var arrowOffsetBase = this.offsets.arrow * 2; // limitMin = trigger.left - (layer.width - arrow.width) + 4\n\n    var limitMin = trigger[oppositeCssProp] - (layer[oppositeSizeProp] - arrow[oppositeSizeProp]) + arrowOffsetBase; // limitMax = trigger.left + (trigger.width - arrow.width) - 4\n\n    var limitMax = trigger[oppositeCssProp] + (trigger[oppositeSizeProp] - arrow[oppositeSizeProp]) - arrowOffsetBase;\n\n    if (!secondary.isPush) {\n      // if secondary is bottom or right -> add the width or height of the layer\n      limitMin += layer[oppositeSizeProp];\n      limitMax += layer[oppositeSizeProp];\n    }\n\n    if (secondary.isCenter) {\n      var propertyA = (isHorizontal ? BoundSide.top : BoundSide.left).prop;\n      var propertyB = (isHorizontal ? BoundSide.bottom : BoundSide.right).prop; // left = limit(\n      //   trigger.left + trigger.width / 2 - layer.width / 2 + secondaryOffset,\n      //   limitMin,\n      //   limitMax\n      // )\n\n      result[propertyA] = limit(trigger[propertyA] + trigger[oppositeSizeProp] / 2 - layer[oppositeSizeProp] / 2 + secondaryOffset, limitMin, limitMax); // right = left + layer.width\n\n      result[propertyB] = result[propertyA] + layer[oppositeSizeProp];\n    } else {\n      var sec = secondary;\n      var triggerValue = trigger[sec.prop]; // Under some conditions, when the layer is not able to align with the trigger\n      // due to arrow-size and arrow-offsets, we need to compensate.\n      // Otherwise, the secondary-offset will have no impact\n\n      var arrowCompensation = triggerValue < limitMin ? limitMin - triggerValue : triggerValue > limitMax ? limitMax - triggerValue : 0; // left = limit(\n      //   trigger.left + secondaryOffset + arrowCompensation,\n      //   limitMin,\n      //   limitMax\n      // )\n\n      result[sec.prop] = limit(triggerValue + secondaryOffset + arrowCompensation, limitMin, limitMax); // right = left + layer.width\n\n      result[sec.opposite.prop] = result[sec.prop] + secondary.factor(layer[oppositeSizeProp]);\n    } // set the correct dimensions\n\n\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top; // create new bounds object\n\n    var layerBounds = Bounds.create(result);\n\n    if (secondaryOffset === 0) {\n      this._cachedLayerBounds = layerBounds;\n    }\n\n    return layerBounds;\n  }\n  /**\r\n   * Checks whether the trigger is bigger on the opposite side\r\n   * ie. placement \"top-start\" -> has trigger a bigger width?\r\n   */\n  ;\n\n  /**\r\n   * returns getLayerBounds(), including container-offsets\r\n   */\n  _proto.getLayerCollisionBounds = function getLayerCollisionBounds() {\n    var container = this.offsets.container;\n    return this.getLayerBounds().mapSides(function (side, value) {\n      return value -= side.factor(container);\n    }).merge(function (_ref) {\n      var width = _ref.width,\n          height = _ref.height;\n      return {\n        width: width + container * 2,\n        height: height + container * 2\n      };\n    });\n  }\n  /**\r\n   * Returns a BoundsOffsets instance containing merged offsets to containers with the most\r\n   * negative scenario\r\n   */\n  ;\n\n  _proto.getContainerOffsets = function getContainerOffsets(layerBounds) {\n    if (this._cachedContainerOffsets && !layerBounds) {\n      return this._cachedContainerOffsets;\n    }\n\n    var subjectBounds = this.subjectsBounds.merge({\n      layer: layerBounds || this.getLayerCollisionBounds()\n    });\n    var offsets = BoundsOffsets.mergeSmallestSides(subjectBounds.layerOffsetsToScrollContainers);\n\n    if (!layerBounds) {\n      this._cachedContainerOffsets = offsets;\n    }\n\n    return offsets;\n  };\n\n  _createClass(Placement, [{\n    key: \"type\",\n    get: function get() {\n      return this.primary.prop + \"-\" + (this.secondary.prop === \"center\" ? \"center\" : [\"bottom\", \"right\"].includes(this.secondary.prop) ? \"end\" : \"start\");\n    }\n  }, {\n    key: \"triggerIsBigger\",\n    get: function get() {\n      var isHorizontal = this.secondary.isHorizontal;\n      var _this$subjectsBounds = this.subjectsBounds,\n          triggerHasBiggerWidth = _this$subjectsBounds.triggerHasBiggerWidth,\n          triggerHasBiggerHeight = _this$subjectsBounds.triggerHasBiggerHeight;\n      return isHorizontal && triggerHasBiggerWidth || !isHorizontal && triggerHasBiggerHeight;\n    }\n    /**\r\n     * Checks whether the placement fits within all it's container (including container-offset)\r\n     */\n\n  }, {\n    key: \"fitsContainer\",\n    get: function get() {\n      return this.getContainerOffsets().allSidesArePositive;\n    }\n    /**\r\n     * Returns the surface in square pixels of the visible part of the layer\r\n     */\n\n  }, {\n    key: \"visibleSurface\",\n    get: function get() {\n      var layerBounds = this.getLayerBounds();\n      var containerOffsets = this.getContainerOffsets(layerBounds);\n      var substract = containerOffsets.negativeSides;\n\n      for (var side in substract) {\n        // @ts-ignore\n        substract[side] = -substract[side]; // make positive for substraction;\n      }\n\n      return layerBounds.substract(substract).surface;\n    }\n    /**\r\n     * Returns a BoundSide by looking at the most negative offset that is the opposite direction\r\n     */\n\n  }, {\n    key: \"secondaryOffsetSide\",\n    get: function get() {\n      var _Object$entries$map$f,\n          _Object$entries$map$f2,\n          _this = this;\n\n      // Given placement 'top-start' and containerOffsets { left: -20, top: -10, right: -10, bottom: 200 }...\n      // the only negative offsets on the opposite side are { left: -20, right: -10 }\n      // since we have to return only 1 side, we pick the most negative, which is 'left'\n      var containerOffsets = this.getContainerOffsets();\n\n      var _ref2 = (_Object$entries$map$f = (_Object$entries$map$f2 = Object.entries(containerOffsets.negativeSides).map(function (_ref3) {\n        var side = _ref3[0],\n            value = _ref3[1];\n        return [BoundSide[side], value];\n      }).filter(function (_ref4) {\n        var side = _ref4[0];\n        return _this.primary.isOppositeDirection(side);\n      }).sort(function (_ref5, _ref6) {\n        var a = _ref5[1];\n        var b = _ref6[1];\n        return b - a;\n      })) == null ? void 0 : _Object$entries$map$f2[0]) != null ? _Object$entries$map$f : [],\n          mostNegativeSide = _ref2[0];\n\n      return mostNegativeSide || null;\n    }\n  }]);\n\n  return Placement;\n}();\nvar PlacementCenter = /*#__PURE__*/function (_Placement) {\n  _inheritsLoose(PlacementCenter, _Placement);\n\n  function PlacementCenter() {\n    return _Placement.apply(this, arguments) || this;\n  }\n\n  var _proto2 = PlacementCenter.prototype;\n\n  _proto2.getLayerBounds = function getLayerBounds() {\n    var _this$subjectsBounds2 = this.subjectsBounds,\n        trigger = _this$subjectsBounds2.trigger,\n        layer = _this$subjectsBounds2.layer;\n    var result = Bounds.empty();\n    result.top = trigger.top + trigger.height / 2 - layer.height / 2;\n    result.bottom = result.top + layer.height;\n    result.left = trigger.left + trigger.width / 2 - layer.width / 2;\n    result.right = result.left + layer.width;\n    result.width = result.right - result.left;\n    result.height = result.bottom - result.top;\n    return result;\n  };\n\n  return PlacementCenter;\n}(Placement);\n\nfunction getNegativeOffsetBetweenLayerCenterAndTrigger(subjectsBounds, placement, arrowOffset) {\n  var layer = subjectsBounds.layer,\n      trigger = subjectsBounds.trigger,\n      arrow = subjectsBounds.arrow;\n  var sizeProperty = placement.primary.oppositeSizeProp;\n\n  var _ref = !placement.primary.isHorizontal ? [\"left\", \"right\"] : [\"top\", \"bottom\"],\n      sideA = _ref[0],\n      sideB = _ref[1];\n\n  var offsetA = layer[sideA] + layer[sizeProperty] / 2 - trigger[sideA] - arrow[sizeProperty] / 2 - arrowOffset;\n  var offsetB = layer[sideB] - layer[sizeProperty] / 2 - trigger[sideB] + arrow[sizeProperty] / 2 + arrowOffset;\n  return (offsetA < 0 ? -offsetA : 0) + (offsetB > 0 ? -offsetB : 0);\n}\n\nvar STYLE_BASE = {\n  position: \"absolute\",\n  willChange: \"top, left\",\n  left: null,\n  right: null,\n  top: null,\n  bottom: null\n};\nfunction getArrowStyle(subjectsBounds, placement, arrowOffset) {\n  var _extends2;\n\n  if (placement.primary.isCenter) {\n    return STYLE_BASE;\n  }\n\n  var layer = subjectsBounds.layer,\n      trigger = subjectsBounds.trigger,\n      arrow = subjectsBounds.arrow;\n  var sizeProperty = placement.primary.oppositeSizeProp;\n  var triggerIsBigger = trigger[sizeProperty] > layer[sizeProperty];\n  var min = arrowOffset + arrow[sizeProperty] / 2;\n  var max = layer[sizeProperty] - arrow[sizeProperty] / 2 - arrowOffset;\n  var negativeOffset = getNegativeOffsetBetweenLayerCenterAndTrigger(subjectsBounds, placement, arrowOffset);\n  var primarySide = placement.primary.prop;\n  var secondarySide = placement.primary.oppositeCssProp;\n  var secondaryValue = triggerIsBigger ? layer[sizeProperty] / 2 + negativeOffset : trigger[secondarySide] + trigger[sizeProperty] / 2 - layer[secondarySide];\n  return _extends({}, STYLE_BASE, (_extends2 = {}, _extends2[primarySide] = \"100%\", _extends2[secondarySide] = limit(secondaryValue, min, max), _extends2));\n}\n\n/**\r\n * Class mostly concerned about calculating and finding the right placement\r\n */\n\nvar Placements = /*#__PURE__*/function () {\n  function Placements(placements, config, subjectsBounds) {\n    this.placements = void 0;\n    this.config = void 0;\n    this.subjectsBounds = void 0;\n    this.placements = placements;\n    this.config = config;\n    this.subjectsBounds = subjectsBounds;\n  }\n  /**\r\n   * Converts a placement-type into a primary-side and a secondary-side\r\n   */\n\n\n  Placements.getSidesFromPlacementType = function getSidesFromPlacementType(type) {\n    var _type$split = type.split(\"-\"),\n        a = _type$split[0],\n        b = _type$split[1];\n\n    var primary = BoundSide[a];\n    var secondary;\n\n    if (b === \"center\") {\n      secondary = Side.center;\n    } else if (primary.isHorizontal) {\n      secondary = b === \"start\" ? Side.top : Side.bottom;\n    } else {\n      secondary = b === \"start\" ? Side.left : Side.right;\n    }\n\n    return [primary, secondary];\n  }\n  /**\r\n   * Main static method to create a Placements instance\r\n   * @param subjectsBounds instance of the SubjectsBounds class\r\n   * @param config config provided by the user\r\n   */\n  ;\n\n  Placements.create = function create(subjectsBounds, config) {\n    // create offsets-object from user config\n    var offsets = {\n      arrow: config.arrowOffset,\n      container: config.containerOffset,\n      trigger: config.triggerOffset\n    }; // function which creates a prioritized list of possible placments\n    // by looking at user-config\n\n    function getListOfPlacements(preferedPlacement) {\n      if (preferedPlacement === void 0) {\n        preferedPlacement = config.placement;\n      }\n\n      var _Placements$getSidesF = Placements.getSidesFromPlacementType(preferedPlacement),\n          primary = _Placements$getSidesF[0],\n          secondary = _Placements$getSidesF[1];\n\n      var preferredSide = BoundSide[primary.isHorizontal ? config.preferY : config.preferX]; // some priorities may alter when the trigger is bigger\n\n      var triggerIsBigger = !primary.isHorizontal && subjectsBounds.triggerHasBiggerWidth || primary.isHorizontal && subjectsBounds.triggerHasBiggerHeight; // utility function which constructs a placement by primary and secondary sides\n\n      function placementFrom(primary, secondary) {\n        return new Placement(primary, secondary, subjectsBounds, config.layerDimensions, offsets);\n      } // creating the list\n\n\n      var list = [];\n      list[0] = placementFrom(primary, secondary);\n      list[1] = placementFrom(primary, secondary.isCenter ? preferredSide : Side.center);\n      list[2] = placementFrom(primary, Side[(secondary.opposite.isCenter ? preferredSide.opposite : secondary.opposite).prop]);\n      list[3] = placementFrom(preferredSide, triggerIsBigger ? primary : Side[primary.opposite.prop]);\n      list[4] = placementFrom(preferredSide, Side.center);\n      list[5] = placementFrom(preferredSide, triggerIsBigger ? Side[primary.opposite.prop] : primary);\n      list[6] = placementFrom(BoundSide[preferredSide.opposite.prop], triggerIsBigger ? primary : Side[primary.opposite.prop]);\n      list[7] = placementFrom(BoundSide[preferredSide.opposite.prop], Side.center);\n      list[8] = placementFrom(BoundSide[preferredSide.opposite.prop], triggerIsBigger ? Side[primary.opposite.prop] : primary);\n      list[9] = placementFrom(BoundSide[primary.opposite.prop], secondary);\n      list[10] = placementFrom(BoundSide[primary.opposite.prop], secondary.isCenter ? preferredSide : Side.center);\n      list[11] = placementFrom(BoundSide[primary.opposite.prop], Side[(secondary.opposite.isCenter ? preferredSide.opposite : secondary.opposite).prop]); // only include placements that are part of 'possible-placements'\n\n      list = list.filter(function (placement) {\n        return placement.type === config.placement || config.possiblePlacements.includes(placement.type);\n      });\n      return list;\n    } // treat placement 'center' a little bit different\n\n\n    if (config.placement === \"center\") {\n      return new Placements([new PlacementCenter(Side.center, Side.center, subjectsBounds, config.layerDimensions, offsets)].concat(getListOfPlacements(config.preferY + \"-\" + config.preferX)), config, subjectsBounds);\n    }\n\n    return new Placements(getListOfPlacements(), config, subjectsBounds);\n  };\n\n  var _proto = Placements.prototype;\n\n  _proto.filterPlacementsBySide = function filterPlacementsBySide(side) {\n    return this.placements.filter(function (placement) {\n      return placement.primary === side;\n    });\n  };\n\n  _proto.findFirstPlacementThatFits = function findFirstPlacementThatFits() {\n    return this.placements.find(function (placement) {\n      return placement.fitsContainer;\n    });\n  };\n\n  _proto.placementWithBiggestVisibleSurface = function placementWithBiggestVisibleSurface() {\n    var _this$placements$map$ = this.placements.map(function (placement) {\n      return {\n        placement: placement,\n        surface: placement.visibleSurface\n      };\n    }) // sort -> biggest surface first\n    . // sort -> biggest surface first\n    sort(function (a, b) {\n      return b.surface - a.surface;\n    }),\n        placementWithBiggestSurface = _this$placements$map$[0].placement;\n\n    return placementWithBiggestSurface;\n  };\n\n  _proto.findSuitablePlacement = function findSuitablePlacement() {\n    if (!this.config.auto) {\n      return this.placements[0];\n    }\n\n    return this.findFirstPlacementThatFits() || this.placementWithBiggestVisibleSurface();\n  }\n  /**\r\n   * secondary offset: the number of pixels between the edge of the\r\n   * scroll-container and the current placement, on the side of the layer\r\n   * that didn't fit.\r\n   * Eventually this secondary offset gets added / subtracted from the\r\n   * placement that does fit in order to move the layer closer to the\r\n   * position of the placement that just would not fit.\r\n   * This creates the effect that the layer is moving gradually from one\r\n   * placement to the next as the users scrolls the page or scroll-container\r\n   */\n  ;\n\n  _proto.getSecondaryOffset = function getSecondaryOffset(placement) {\n    var _this$config = this.config,\n        auto = _this$config.auto,\n        snap = _this$config.snap; // return early when we're not interested...\n\n    if (!auto || snap || placement instanceof PlacementCenter) {\n      return 0;\n    } // if current placement fits and is prefered placement...\n    // return early\n\n\n    var placementsOnSameSide = this.filterPlacementsBySide(placement.primary);\n    var currentPlacementHasHighestPriority = placementsOnSameSide.indexOf(placement) === 0;\n\n    if (currentPlacementHasHighestPriority && placement.fitsContainer) {\n      return 0;\n    }\n\n    var firstPlacementThatDoesNotFit = placementsOnSameSide.find(function (placement) {\n      return !placement.fitsContainer;\n    });\n\n    if (!firstPlacementThatDoesNotFit) {\n      return 0;\n    }\n\n    var secondaryOffsetSide = firstPlacementThatDoesNotFit.secondaryOffsetSide;\n\n    if (!secondaryOffsetSide) {\n      return 0;\n    }\n\n    var containerOffsets = placement.getContainerOffsets(); // determine whether we should add or substract the secondary-offset\n\n    var secondary = placement.secondary;\n    var factor;\n\n    if (placement.triggerIsBigger || firstPlacementThatDoesNotFit === placement) {\n      factor = secondaryOffsetSide.isPush ? -1 : 1;\n    } else {\n      factor = secondary === Side.left || [Side.top, Side.center].includes(secondary) && secondaryOffsetSide.isPush ? -1 : 1;\n    } // get number of pixels between placement that did not fit and current\n    // placement\n\n\n    var secondaryOffset = containerOffsets[secondaryOffsetSide.prop];\n    return secondaryOffset * factor;\n  };\n\n  _proto.getStyles = function getStyles(layerBounds, placement, scrollOffsets, borderOffsets) {\n    var layerStyleBase = {\n      willChange: \"top, left, width, height\"\n    };\n    var arrow = getArrowStyle(this.subjectsBounds.merge({\n      layer: layerBounds\n    }), placement, this.config.arrowOffset);\n    var layer = this.config.overflowContainer ? _extends({}, layerStyleBase, {\n      position: \"fixed\",\n      top: layerBounds.top,\n      left: layerBounds.left\n    }) : _extends({}, layerStyleBase, {\n      position: \"absolute\",\n      top: layerBounds.top - this.subjectsBounds.parent.top + scrollOffsets.top - borderOffsets.top,\n      left: layerBounds.left - this.subjectsBounds.parent.left + scrollOffsets.left - borderOffsets.left\n    });\n    return {\n      arrow: arrow,\n      layer: layer\n    };\n  };\n\n  _proto.getHasDisappeared = function getHasDisappeared(layerBounds) {\n    var subject = this.config.overflowContainer ? this.subjectsBounds.trigger : layerBounds;\n    var containerOffsets = BoundsOffsets.mergeSmallestSides(this.subjectsBounds.offsetsToScrollContainers(subject, true));\n    var entries = Object.entries(containerOffsets.negativeSides);\n    var hasFullyDisappeared = entries.some(function (_ref) {\n      var prop = _ref[0],\n          value = _ref[1];\n      var side = BoundSide[prop];\n      return value <= -subject[side.sizeProp];\n    });\n\n    if (hasFullyDisappeared) {\n      return \"full\";\n    }\n\n    if (!containerOffsets.allSidesArePositive) {\n      return \"partial\";\n    }\n\n    return null;\n  };\n\n  _proto.result = function result(scrollOffsets, borderOffsets) {\n    var suitablePlacement = this.findSuitablePlacement();\n    var secondaryOffset = this.getSecondaryOffset(suitablePlacement);\n    var layerBounds = suitablePlacement.getLayerBounds(secondaryOffset);\n    var styles = this.getStyles(layerBounds, suitablePlacement, scrollOffsets, borderOffsets);\n    var layerSide = suitablePlacement.primary.prop;\n    return {\n      styles: styles,\n      layerSide: layerSide,\n      placement: suitablePlacement,\n      layerBounds: layerBounds,\n      hasDisappeared: this.getHasDisappeared(layerBounds)\n    };\n  };\n\n  return Placements;\n}();\n\nvar SubjectsBounds = /*#__PURE__*/function () {\n  function SubjectsBounds(subjectsBounds, overflowContainer) {\n    this.overflowContainer = void 0;\n    this.trigger = void 0;\n    this.layer = void 0;\n    this.arrow = void 0;\n    this.parent = void 0;\n    this.window = void 0;\n    this.scrollContainers = void 0;\n    this.overflowContainer = overflowContainer;\n    Object.assign(this, subjectsBounds);\n  }\n\n  SubjectsBounds.create = function create(environment, layer, trigger, parent, arrow, scrollContainers, overflowContainer, getTriggerBounds) {\n    var window = Bounds.fromWindow(environment);\n    return new SubjectsBounds({\n      layer: Bounds.fromElement(layer, {\n        environment: environment,\n        withTransform: false\n      }),\n      trigger: getTriggerBounds ? Bounds.create(boundsToObject(getTriggerBounds())) : Bounds.fromElement(trigger),\n      arrow: arrow ? Bounds.fromElement(arrow) : Bounds.empty(),\n      parent: parent ? Bounds.fromElement(parent) : window,\n      window: window,\n      scrollContainers: [window].concat(scrollContainers.map(function (container) {\n        return Bounds.fromElement(container, {\n          withScrollbars: false\n        });\n      }))\n    }, overflowContainer);\n  };\n\n  var _proto = SubjectsBounds.prototype;\n\n  _proto.merge = function merge(subjectsBounds) {\n    return new SubjectsBounds(_extends({}, this, subjectsBounds), this.overflowContainer);\n  };\n\n  _proto.offsetsToScrollContainers = function offsetsToScrollContainers(subject, allContainers) {\n    if (allContainers === void 0) {\n      allContainers = false;\n    }\n\n    var scrollContainers = this.overflowContainer && !allContainers ? [this.window] : this.scrollContainers;\n    return scrollContainers.map(function (scrollContainer) {\n      return scrollContainer.offsetsTo(subject);\n    });\n  };\n\n  _createClass(SubjectsBounds, [{\n    key: \"layerOffsetsToScrollContainers\",\n    get: function get() {\n      return this.offsetsToScrollContainers(this.layer);\n    }\n  }, {\n    key: \"triggerHasBiggerWidth\",\n    get: function get() {\n      return this.trigger.width > this.layer.width;\n    }\n  }, {\n    key: \"triggerHasBiggerHeight\",\n    get: function get() {\n      return this.trigger.height > this.layer.height;\n    }\n  }]);\n\n  return SubjectsBounds;\n}();\n\nvar GLOBAL_CONTAINER = null;\nfunction setGlobalContainer(container) {\n  if (typeof document === \"undefined\") {\n    return;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(!(GLOBAL_CONTAINER instanceof HTMLElement), \"react-laag: You've called 'setGlobalContainer() previously'. It is recommended to only set the global container once, otherwise this may lead to unexpected behaviour.\") : void 0;\n\n  if (typeof container === \"function\") {\n    GLOBAL_CONTAINER = container();\n  } else if (typeof container === \"string\") {\n    GLOBAL_CONTAINER = document.getElementById(container);\n  } else {\n    GLOBAL_CONTAINER = container;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(GLOBAL_CONTAINER instanceof HTMLElement, \"react-laag: You've called 'setGlobalContainer()', but it didn't result in a valid html-element\") : void 0;\n}\nvar DEFAULT_OPTIONS = {\n  auto: false,\n  arrowOffset: 0,\n  containerOffset: 10,\n  triggerOffset: 0,\n  overflowContainer: true,\n  placement: \"top-center\",\n  possiblePlacements: PLACEMENT_TYPES,\n  preferX: \"right\",\n  preferY: \"bottom\",\n  snap: false,\n  container: undefined,\n  trigger: undefined\n};\nfunction useLayer(_ref) {\n  var _triggerBoundsRef$cur;\n\n  var _ref$isOpen = _ref.isOpen,\n      isOpen = _ref$isOpen === void 0 ? false : _ref$isOpen,\n      _ref$overflowContaine = _ref.overflowContainer,\n      overflowContainer = _ref$overflowContaine === void 0 ? DEFAULT_OPTIONS.overflowContainer : _ref$overflowContaine,\n      _ref$environment = _ref.environment,\n      environment = _ref$environment === void 0 ? typeof window !== \"undefined\" ? window : undefined : _ref$environment,\n      ResizeObserverPolyfill = _ref.ResizeObserver,\n      _ref$placement = _ref.placement,\n      placement = _ref$placement === void 0 ? DEFAULT_OPTIONS.placement : _ref$placement,\n      _ref$possiblePlacemen = _ref.possiblePlacements,\n      possiblePlacements = _ref$possiblePlacemen === void 0 ? DEFAULT_OPTIONS.possiblePlacements : _ref$possiblePlacemen,\n      _ref$preferX = _ref.preferX,\n      preferX = _ref$preferX === void 0 ? DEFAULT_OPTIONS.preferX : _ref$preferX,\n      _ref$preferY = _ref.preferY,\n      preferY = _ref$preferY === void 0 ? DEFAULT_OPTIONS.preferY : _ref$preferY,\n      _ref$auto = _ref.auto,\n      auto = _ref$auto === void 0 ? DEFAULT_OPTIONS.auto : _ref$auto,\n      _ref$snap = _ref.snap,\n      snap = _ref$snap === void 0 ? DEFAULT_OPTIONS.snap : _ref$snap,\n      _ref$triggerOffset = _ref.triggerOffset,\n      triggerOffset = _ref$triggerOffset === void 0 ? DEFAULT_OPTIONS.triggerOffset : _ref$triggerOffset,\n      _ref$containerOffset = _ref.containerOffset,\n      containerOffset = _ref$containerOffset === void 0 ? DEFAULT_OPTIONS.containerOffset : _ref$containerOffset,\n      _ref$arrowOffset = _ref.arrowOffset,\n      arrowOffset = _ref$arrowOffset === void 0 ? DEFAULT_OPTIONS.arrowOffset : _ref$arrowOffset,\n      _ref$container = _ref.container,\n      container = _ref$container === void 0 ? DEFAULT_OPTIONS.container : _ref$container,\n      _ref$layerDimensions = _ref.layerDimensions,\n      layerDimensions = _ref$layerDimensions === void 0 ? null : _ref$layerDimensions,\n      onDisappear = _ref.onDisappear,\n      onOutsideClick = _ref.onOutsideClick,\n      onParentClose = _ref.onParentClose,\n      triggerOption = _ref.trigger;\n\n  // initialize styles\n  var _useState = useState(function () {\n    return {\n      layerSide: placement === \"center\" ? \"center\" : Placements.getSidesFromPlacementType(placement)[0].prop,\n      styles: {\n        layer: {\n          position: overflowContainer ? \"fixed\" : \"absolute\",\n          top: 0,\n          left: 0\n        },\n        arrow: {\n          position: \"absolute\",\n          top: 0,\n          left: 0\n        }\n      }\n    };\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var triggerBoundsRef = useRef(null); // tracks state in order for us to use read inside functions that require dependencies,\n  // like `useCallback`, without triggering an update\n\n  var lastState = useLastState(state, isOpen); // track invalidations for scheduled position updates\n\n  var repositioningToken = useRef({\n    cancelled: false\n  });\n  useEffect(function () {\n    return function () {\n      // when this hook unmounts, make sure to cancel any scheduled position updates\n      repositioningToken.current.cancelled = true;\n    };\n  }, []); // Most important function regarding positioning\n  // It receives boundaries collected by `useTrackElements`, does some calculations,\n  // sets new styles, and handles when a layer has disappeared.\n\n  var handlePositioning = useCallback(function handlePositioning(_ref2, scrollOffsets, borderOffsets) {\n    var arrow = _ref2.arrow,\n        layer = _ref2.layer,\n        scrollContainers = _ref2.scrollContainers,\n        trigger = _ref2.trigger;\n    var parent = scrollContainers[0];\n    var subjectsBounds = SubjectsBounds.create(environment, layer, trigger, parent, arrow, scrollContainers, overflowContainer, triggerOption == null ? void 0 : triggerOption.getBounds);\n    var config = {\n      placement: placement,\n      possiblePlacements: possiblePlacements,\n      auto: auto,\n      layerDimensions: layerDimensions,\n      arrowOffset: arrowOffset,\n      containerOffset: containerOffset,\n      triggerOffset: triggerOffset,\n      preferX: preferX,\n      preferY: preferY,\n      snap: snap,\n      overflowContainer: overflowContainer\n    };\n\n    var _Placements$create$re = Placements.create(subjectsBounds, config).result(scrollOffsets, borderOffsets),\n        hasDisappeared = _Placements$create$re.hasDisappeared,\n        layerSide = _Placements$create$re.layerSide,\n        styles = _Placements$create$re.styles;\n\n    var newState = {\n      layerSide: layerSide,\n      styles: styles\n    };\n\n    if (!lastState.current || didStateChange(lastState.current, newState)) {\n      lastState.current = newState; // optimistically update lastState to prevent infinite loop\n\n      /**\r\n       * Throttle state updates slightly by delaying them using an immediately\r\n       * resolved promise, only applying them if there is no later update.\r\n       * This helps for multiple updates that happens synchronously one after another.\r\n       */\n\n      repositioningToken.current.cancelled = true;\n      var token = {\n        cancelled: false\n      };\n      repositioningToken.current = token;\n      Promise.resolve().then(function () {\n        if (!token.cancelled) {\n          setState(newState);\n        }\n      });\n    }\n\n    if (isSet(hasDisappeared) && isSet(onDisappear)) {\n      onDisappear(hasDisappeared);\n    }\n  }, [arrowOffset, auto, containerOffset, environment, layerDimensions, onDisappear, overflowContainer, placement, possiblePlacements, preferX, preferY, snap, triggerOffset, lastState, triggerOption]);\n\n  var _useTrackElements = useTrackElements({\n    ResizeObserverPolyfill: ResizeObserverPolyfill,\n    environment: environment,\n    enabled: isOpen,\n    overflowContainer: overflowContainer,\n    onChange: handlePositioning,\n    triggerOption: triggerOption\n  }),\n      triggerRef = _useTrackElements.triggerRef,\n      layerRef = _useTrackElements.layerRef,\n      arrowRef = _useTrackElements.arrowRef,\n      closestScrollContainer = _useTrackElements.closestScrollContainer;\n\n  var _useGroup = useGroup({\n    isOpen: isOpen,\n    onOutsideClick: onOutsideClick,\n    onParentClose: onParentClose\n  }),\n      closeOnOutsideClickRefs = _useGroup.closeOnOutsideClickRefs,\n      registrations = _useGroup.registrations;\n\n  var props = {\n    triggerProps: Boolean(triggerOption) ? {} // when using the `trigger` option, make `triggerProps` useless\n    : {\n      ref: mergeRefs(triggerRef, closeOnOutsideClickRefs.trigger, triggerBoundsRef)\n    },\n    layerProps: {\n      ref: mergeRefs(layerRef, closeOnOutsideClickRefs.layer),\n      style: state.styles.layer\n    },\n    arrowProps: {\n      ref: arrowRef,\n      style: state.styles.arrow,\n      layerSide: state.layerSide\n    },\n    layerSide: state.layerSide,\n    triggerBounds: isOpen ? triggerOption ? triggerOption.getBounds() : (_triggerBoundsRef$cur = triggerBoundsRef.current) == null ? void 0 : _triggerBoundsRef$cur.getBoundingClientRect() : null,\n    renderLayer: function renderLayer(children) {\n      return typeof document !== \"undefined\" ? createPortal(createElement(GroupProvider, {\n        registrations: registrations,\n        children: children\n      }), overflowContainer || !closestScrollContainer ? getContainerElement(container) : closestScrollContainer) : null;\n    }\n  };\n  return props;\n}\n\nfunction didStateChange(previous, next) {\n  if (previous.layerSide !== next.layerSide) {\n    return true;\n  }\n\n  var styleProps = [\"position\", \"top\", \"left\", \"right\", \"bottom\"];\n\n  for (var _i = 0, _styleProps = styleProps; _i < _styleProps.length; _i++) {\n    var prop = _styleProps[_i];\n\n    if (previous.styles.layer[prop] !== next.styles.layer[prop] || previous.styles.arrow[prop] !== next.styles.arrow[prop]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar DEFAULT_CONTAINER_ID = \"layers\";\n\nfunction getContainerElement(container) {\n  var element;\n\n  if (typeof container === \"function\") {\n    element = container();\n\n    if (!element || !(element instanceof HTMLElement)) {\n      throw new Error(\"react-laag: You've passed a function to the 'container' prop, but it returned no valid HTMLElement\");\n    }\n  } else if (container instanceof HTMLElement) {\n    element = container;\n  } else if (typeof container === \"string\") {\n    element = document.getElementById(container);\n\n    if (!element) {\n      throw new Error(\"react-laag: You've passed element with id '\" + container + \"' to the 'container' prop, but it returned no valid HTMLElement\");\n    }\n  } else if (GLOBAL_CONTAINER instanceof HTMLElement) {\n    return GLOBAL_CONTAINER;\n  } else {\n    element = document.getElementById(DEFAULT_CONTAINER_ID);\n\n    if (!element) {\n      element = document.createElement(\"div\");\n      element.id = DEFAULT_CONTAINER_ID;\n      element.style.cssText = \"\\n        position: absolute;\\n        top: 0px;\\n        left: 0px;\\n        right: 0px;\\n      \";\n      document.body.appendChild(element);\n    }\n  }\n\n  return element;\n}\n\nvar _excluded = [\"size\", \"angle\", \"borderWidth\", \"borderColor\", \"roundness\", \"backgroundColor\", \"layerSide\", \"style\"];\nvar LEFT = \"left\";\nvar TOP = \"top\";\nvar BOTTOM = \"bottom\";\nvar RIGHT = \"right\";\n\nfunction getWidthBasedOnAngle(angle, size) {\n  return Math.tan(angle * (Math.PI / 180)) * size;\n}\n\nfunction getViewBox(sizeA, sizeB, side, borderWidth) {\n  var _map;\n\n  var map = (_map = {}, _map[BOTTOM] = \"0 \" + -borderWidth + \" \" + sizeB + \" \" + sizeA, _map[TOP] = \"0 0 \" + sizeB + \" \" + (sizeA + borderWidth), _map[RIGHT] = -borderWidth + \" 0 \" + sizeA + \" \" + sizeB, _map[LEFT] = \"0 0 \" + (sizeA + borderWidth) + \" \" + sizeB, _map);\n  return map[side.prop];\n}\n\nfunction getTrianglePath(sizeA, sizeB, side, roundness, angle) {\n  var _BOTTOM$TOP$RIGHT$LEF, _BOTTOM$TOP$RIGHT$LEF2, _BOTTOM$TOP$RIGHT$LEF3;\n\n  var relativeRoundness = roundness / 10 * sizeA * 2;\n  var A = (_BOTTOM$TOP$RIGHT$LEF = {}, _BOTTOM$TOP$RIGHT$LEF[BOTTOM] = [0, sizeA], _BOTTOM$TOP$RIGHT$LEF[TOP] = [0, 0], _BOTTOM$TOP$RIGHT$LEF[RIGHT] = [sizeA, sizeB], _BOTTOM$TOP$RIGHT$LEF[LEFT] = [0, sizeB], _BOTTOM$TOP$RIGHT$LEF)[side.prop].join(\" \");\n  var B = side.isHorizontal ? \"V 0\" : \"H \" + sizeB;\n  var cPoint = sizeB / 2;\n  var c1A = sizeB / 2 + getWidthBasedOnAngle(angle, sizeA / 8);\n  var c1B = sizeA / 8;\n  var C = (_BOTTOM$TOP$RIGHT$LEF2 = {}, _BOTTOM$TOP$RIGHT$LEF2[BOTTOM] = [\"C\", c1A, c1B, cPoint + relativeRoundness, 0, cPoint, 0], _BOTTOM$TOP$RIGHT$LEF2[TOP] = [\"C\", c1A, sizeA - c1B, cPoint + relativeRoundness, sizeA, cPoint, sizeA], _BOTTOM$TOP$RIGHT$LEF2[RIGHT] = [\"C\", c1B, sizeB - c1A, 0, cPoint - relativeRoundness, 0, cPoint], _BOTTOM$TOP$RIGHT$LEF2[LEFT] = [\"C\", sizeA - c1B, sizeB - c1A, sizeA, cPoint - relativeRoundness, sizeA, cPoint], _BOTTOM$TOP$RIGHT$LEF2)[side.prop].join(\" \");\n  var d1A = sizeB / 2 - getWidthBasedOnAngle(angle, sizeA / 8);\n  var d1B = sizeA / 8;\n  var D = (_BOTTOM$TOP$RIGHT$LEF3 = {}, _BOTTOM$TOP$RIGHT$LEF3[BOTTOM] = [\"C\", cPoint - relativeRoundness, 0, d1A, d1B, A], _BOTTOM$TOP$RIGHT$LEF3[TOP] = [\"C\", cPoint - relativeRoundness, sizeA, d1A, sizeA - d1B, A], _BOTTOM$TOP$RIGHT$LEF3[RIGHT] = [\"C\", 0, cPoint + relativeRoundness, d1B, sizeB - d1A, A], _BOTTOM$TOP$RIGHT$LEF3[LEFT] = [\"C\", sizeA, cPoint + relativeRoundness, sizeA - d1B, sizeB - d1A, A], _BOTTOM$TOP$RIGHT$LEF3)[side.prop].join(\" \");\n  return [\"M\", A, B, C, D].join(\" \");\n}\n\nfunction getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle) {\n  var borderOffset = getWidthBasedOnAngle(angle, borderWidth);\n\n  var _ref = !side.isPush ? [sizeA, sizeA - borderWidth] : [0, borderWidth],\n      A = _ref[0],\n      B = _ref[1];\n\n  if (side.isHorizontal) {\n    return [\"M\", A, borderWidth, \"V\", sizeB - borderWidth, \"L\", B, sizeB - borderWidth - borderOffset, \"V\", borderOffset + borderWidth, \"Z\"].join(\" \");\n  }\n\n  return [\"M\", borderWidth, A, \"H\", sizeB - borderWidth, \"L\", sizeB - borderWidth - borderOffset, B, \"H\", borderOffset + borderWidth, \"Z\"].join(\" \");\n}\n\nvar Arrow = /*#__PURE__*/forwardRef(function Arrow(_ref2, ref) {\n  var _ref2$size = _ref2.size,\n      size = _ref2$size === void 0 ? 8 : _ref2$size,\n      _ref2$angle = _ref2.angle,\n      angle = _ref2$angle === void 0 ? 45 : _ref2$angle,\n      _ref2$borderWidth = _ref2.borderWidth,\n      borderWidth = _ref2$borderWidth === void 0 ? 0 : _ref2$borderWidth,\n      _ref2$borderColor = _ref2.borderColor,\n      borderColor = _ref2$borderColor === void 0 ? \"black\" : _ref2$borderColor,\n      _ref2$roundness = _ref2.roundness,\n      roundness = _ref2$roundness === void 0 ? 0 : _ref2$roundness,\n      _ref2$backgroundColor = _ref2.backgroundColor,\n      backgroundColor = _ref2$backgroundColor === void 0 ? \"white\" : _ref2$backgroundColor,\n      _ref2$layerSide = _ref2.layerSide,\n      layerSide = _ref2$layerSide === void 0 ? \"top\" : _ref2$layerSide,\n      _ref2$style = _ref2.style,\n      style = _ref2$style === void 0 ? {} : _ref2$style,\n      rest = _objectWithoutPropertiesLoose(_ref2, _excluded);\n\n  if (layerSide === \"center\") {\n    return null;\n  }\n\n  var side = BoundSide[layerSide];\n  var sizeA = size;\n  var sizeB = getWidthBasedOnAngle(angle, size) * 2;\n  var maxSize = Math.max(sizeA, sizeB);\n  return createElement(\"svg\", _extends({\n    ref: ref\n  }, rest, {\n    style: _extends({}, style, {\n      transform: \"translate\" + (side.isHorizontal ? \"Y\" : \"X\") + \"(-50%)\"\n    }),\n    width: maxSize,\n    height: maxSize,\n    preserveAspectRatio: side.isPush ? \"xMinYMin\" : \"xMaxYMax\",\n    viewBox: getViewBox(sizeA, sizeB, side, borderWidth)\n  }), createElement(\"path\", {\n    fill: backgroundColor,\n    strokeWidth: borderWidth,\n    stroke: borderColor,\n    d: getTrianglePath(sizeA, sizeB, side, roundness, angle)\n  }), createElement(\"path\", {\n    fill: backgroundColor,\n    d: getBorderMaskPath(sizeA, sizeB, borderWidth, side, angle)\n  }));\n});\n\nvar Status;\n\n(function (Status) {\n  Status[Status[\"ENTERING\"] = 0] = \"ENTERING\";\n  Status[Status[\"LEAVING\"] = 1] = \"LEAVING\";\n  Status[Status[\"IDLE\"] = 2] = \"IDLE\";\n})(Status || (Status = {}));\n\nfunction useHover(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$delayEnter = _ref.delayEnter,\n      delayEnter = _ref$delayEnter === void 0 ? 0 : _ref$delayEnter,\n      _ref$delayLeave = _ref.delayLeave,\n      delayLeave = _ref$delayLeave === void 0 ? 0 : _ref$delayLeave,\n      _ref$hideOnScroll = _ref.hideOnScroll,\n      hideOnScroll = _ref$hideOnScroll === void 0 ? true : _ref$hideOnScroll;\n\n  var _useState = useState(false),\n      show = _useState[0],\n      setShow = _useState[1];\n\n  var timeout = useRef(null);\n  var status = useRef(Status.IDLE);\n  var hasTouchMoved = useRef(false);\n  var removeTimeout = useCallback(function removeTimeout() {\n    clearTimeout(timeout.current);\n    timeout.current = null;\n    status.current = Status.IDLE;\n  }, []);\n\n  function onMouseEnter() {\n    // if was leaving, stop leaving\n    if (status.current === Status.LEAVING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (show) {\n      return;\n    }\n\n    status.current = Status.ENTERING;\n    timeout.current = window.setTimeout(function () {\n      setShow(true);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayEnter);\n  }\n\n  function onMouseLeave(_, immediate) {\n    // if was waiting for entering,\n    // clear timeout\n    if (status.current === Status.ENTERING && timeout.current) {\n      removeTimeout();\n    }\n\n    if (!show) {\n      return;\n    }\n\n    if (immediate) {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n      return;\n    }\n\n    status.current = Status.LEAVING;\n    timeout.current = window.setTimeout(function () {\n      setShow(false);\n      timeout.current = null;\n      status.current = Status.IDLE;\n    }, delayLeave);\n  } // make sure to clear timeout on unmount\n\n\n  useEffect(function () {\n    function onScroll() {\n      if (show && hideOnScroll) {\n        removeTimeout();\n        setShow(false);\n      }\n    }\n\n    window.addEventListener(\"scroll\", onScroll, true);\n    return function () {\n      window.removeEventListener(\"scroll\", onScroll, true);\n\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, [show, hideOnScroll, removeTimeout]);\n  var hoverProps = {\n    onMouseEnter: onMouseEnter,\n    onMouseLeave: onMouseLeave,\n    onTouchStart: function onTouchStart() {\n      hasTouchMoved.current = false;\n    },\n    onTouchMove: function onTouchMove() {\n      hasTouchMoved.current = true;\n    },\n    onTouchEnd: function onTouchEnd() {\n      if (!hasTouchMoved.current && !show) {\n        setShow(true);\n      }\n\n      hasTouchMoved.current = false;\n    }\n  };\n  return [show, hoverProps, function () {\n    return onMouseLeave(null, true);\n  }];\n}\n\n/**\r\n * @deprecated\r\n * Note: this component is marked as deprecated and will be removed and a possible\r\n * future release\r\n */\n\nfunction Transition(_ref) {\n  var isOpenExternal = _ref.isOpen,\n      children = _ref.children;\n\n  var _useState = useState({\n    isOpenInternal: isOpenExternal,\n    isLeaving: false\n  }),\n      state = _useState[0],\n      setState = _useState[1];\n\n  var didMount = useRef(false);\n  useEffect(function () {\n    if (isOpenExternal) {\n      setState({\n        isOpenInternal: true,\n        isLeaving: false\n      });\n    } else if (didMount.current) {\n      setState({\n        isOpenInternal: false,\n        isLeaving: true\n      });\n    }\n  }, [isOpenExternal, setState]);\n  useEffect(function () {\n    process.env.NODE_ENV !== \"production\" ? warning(children, \"react-laag: You are using 'Transition'. Note that this component is marked as deprecated and will be removed at future releases\") : void 0;\n  }, [children]);\n  useEffect(function () {\n    didMount.current = true;\n  }, []);\n\n  if (!isOpenExternal && !state.isOpenInternal && !state.isLeaving) {\n    return null;\n  }\n\n  return children(state.isOpenInternal, function () {\n    if (!state.isOpenInternal) {\n      setState(function (s) {\n        return _extends({}, s, {\n          isLeaving: false\n        });\n      });\n    }\n  }, state.isLeaving);\n}\n\nexport { Arrow, DEFAULT_OPTIONS, PLACEMENT_TYPES, Transition, mergeRefs, setGlobalContainer, useHover, useLayer, useMousePositionAsTrigger };\n//# sourceMappingURL=react-laag.esm.js.map\n","/** @license React v17.0.2\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var b=60103,c=60106,d=60107,e=60108,f=60114,g=60109,h=60110,k=60112,l=60113,m=60120,n=60115,p=60116,q=60121,r=60122,u=60117,v=60129,w=60131;\nif(\"function\"===typeof Symbol&&Symbol.for){var x=Symbol.for;b=x(\"react.element\");c=x(\"react.portal\");d=x(\"react.fragment\");e=x(\"react.strict_mode\");f=x(\"react.profiler\");g=x(\"react.provider\");h=x(\"react.context\");k=x(\"react.forward_ref\");l=x(\"react.suspense\");m=x(\"react.suspense_list\");n=x(\"react.memo\");p=x(\"react.lazy\");q=x(\"react.block\");r=x(\"react.server.block\");u=x(\"react.fundamental\");v=x(\"react.debug_trace_mode\");w=x(\"react.legacy_hidden\")}\nfunction y(a){if(\"object\"===typeof a&&null!==a){var t=a.$$typeof;switch(t){case b:switch(a=a.type,a){case d:case f:case e:case l:case m:return a;default:switch(a=a&&a.$$typeof,a){case h:case k:case p:case n:case g:return a;default:return t}}case c:return t}}}var z=g,A=b,B=k,C=d,D=p,E=n,F=c,G=f,H=e,I=l;exports.ContextConsumer=h;exports.ContextProvider=z;exports.Element=A;exports.ForwardRef=B;exports.Fragment=C;exports.Lazy=D;exports.Memo=E;exports.Portal=F;exports.Profiler=G;exports.StrictMode=H;\nexports.Suspense=I;exports.isAsyncMode=function(){return!1};exports.isConcurrentMode=function(){return!1};exports.isContextConsumer=function(a){return y(a)===h};exports.isContextProvider=function(a){return y(a)===g};exports.isElement=function(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===b};exports.isForwardRef=function(a){return y(a)===k};exports.isFragment=function(a){return y(a)===d};exports.isLazy=function(a){return y(a)===p};exports.isMemo=function(a){return y(a)===n};\nexports.isPortal=function(a){return y(a)===c};exports.isProfiler=function(a){return y(a)===f};exports.isStrictMode=function(a){return y(a)===e};exports.isSuspense=function(a){return y(a)===l};exports.isValidElementType=function(a){return\"string\"===typeof a||\"function\"===typeof a||a===d||a===f||a===v||a===e||a===l||a===m||a===w||\"object\"===typeof a&&null!==a&&(a.$$typeof===p||a.$$typeof===n||a.$$typeof===g||a.$$typeof===h||a.$$typeof===k||a.$$typeof===u||a.$$typeof===q||a[0]===r)?!0:!1};\nexports.typeOf=y;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n","function t(t){return\"object\"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return(!e||\"hidden\"!==t)&&\"visible\"!==t&&\"clip\"!==t}function n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return e(r.overflowY,n)||e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return!1}function r(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}var i=function(e,i){var o=window,l=i.scrollMode,d=i.block,f=i.inline,h=i.boundary,u=i.skipOverflowHiddenElements,s=\"function\"==typeof h?h:function(t){return t!==h};if(!t(e))throw new TypeError(\"Invalid target\");for(var a,c,g=document.scrollingElement||document.documentElement,p=[],m=e;t(m)&&s(m);){if((m=null==(c=(a=m).parentElement)?a.getRootNode().host||null:c)===g){p.push(m);break}null!=m&&m===document.body&&n(m)&&!n(document.documentElement)||null!=m&&n(m,u)&&p.push(m)}for(var w=o.visualViewport?o.visualViewport.width:innerWidth,v=o.visualViewport?o.visualViewport.height:innerHeight,W=window.scrollX||pageXOffset,H=window.scrollY||pageYOffset,b=e.getBoundingClientRect(),y=b.height,E=b.width,M=b.top,V=b.right,x=b.bottom,I=b.left,C=\"start\"===d||\"nearest\"===d?M:\"end\"===d?x:M+y/2,R=\"center\"===f?I+E/2:\"end\"===f?V:I,T=[],k=0;k<p.length;k++){var B=p[k],D=B.getBoundingClientRect(),O=D.height,X=D.width,Y=D.top,L=D.right,S=D.bottom,j=D.left;if(\"if-needed\"===l&&M>=0&&I>=0&&x<=v&&V<=w&&M>=Y&&x<=S&&I>=j&&V<=L)return T;var N=getComputedStyle(B),q=parseInt(N.borderLeftWidth,10),z=parseInt(N.borderTopWidth,10),A=parseInt(N.borderRightWidth,10),F=parseInt(N.borderBottomWidth,10),G=0,J=0,K=\"offsetWidth\"in B?B.offsetWidth-B.clientWidth-q-A:0,P=\"offsetHeight\"in B?B.offsetHeight-B.clientHeight-z-F:0,Q=\"offsetWidth\"in B?0===B.offsetWidth?0:X/B.offsetWidth:0,U=\"offsetHeight\"in B?0===B.offsetHeight?0:O/B.offsetHeight:0;if(g===B)G=\"start\"===d?C:\"end\"===d?C-v:\"nearest\"===d?r(H,H+v,v,z,F,H+C,H+C+y,y):C-v/2,J=\"start\"===f?R:\"center\"===f?R-w/2:\"end\"===f?R-w:r(W,W+w,w,q,A,W+R,W+R+E,E),G=Math.max(0,G+H),J=Math.max(0,J+W);else{G=\"start\"===d?C-Y-z:\"end\"===d?C-S+F+P:\"nearest\"===d?r(Y,S,O,z,F+P,C,C+y,y):C-(Y+O/2)+P/2,J=\"start\"===f?R-j-q:\"center\"===f?R-(j+X/2)+K/2:\"end\"===f?R-L+A+K:r(j,L,X,q,A+K,R,R+E,E);var Z=B.scrollLeft,$=B.scrollTop;C+=$-(G=Math.max(0,Math.min($+G/U,B.scrollHeight-O/U+P))),R+=Z-(J=Math.max(0,Math.min(Z+J/Q,B.scrollWidth-X/Q+K)))}T.push({el:B,top:G,left:J})}return T};export{i as default};\n//# sourceMappingURL=index.mjs.map\n","import PropTypes from 'prop-types';\nimport { Component, cloneElement, useRef, useEffect, useCallback, useLayoutEffect, useReducer, useMemo } from 'react';\nimport { isForwardRef } from 'react-is';\nimport computeScrollIntoView from 'compute-scroll-into-view';\nimport { __assign } from 'tslib';\n\nlet idCounter = 0;\n/**\n * Accepts a parameter and returns it if it's a function\n * or a noop function if it's not. This allows us to\n * accept a callback, but not worry about it if it's not\n * passed.\n * @param {Function} cb the callback\n * @return {Function} a function\n */\n\nfunction cbToCb(cb) {\n  return typeof cb === 'function' ? cb : noop;\n}\n\nfunction noop() {}\n/**\n * Scroll node into view if necessary\n * @param {HTMLElement} node the element that should scroll into view\n * @param {HTMLElement} menuNode the menu element of the component\n */\n\n\nfunction scrollIntoView(node, menuNode) {\n  if (!node) {\n    return;\n  }\n\n  const actions = computeScrollIntoView(node, {\n    boundary: menuNode,\n    block: 'nearest',\n    scrollMode: 'if-needed'\n  });\n  actions.forEach(_ref => {\n    let {\n      el,\n      top,\n      left\n    } = _ref;\n    el.scrollTop = top;\n    el.scrollLeft = left;\n  });\n}\n/**\n * @param {HTMLElement} parent the parent node\n * @param {HTMLElement} child the child node\n * @param {Window} environment The window context where downshift renders.\n * @return {Boolean} whether the parent is the child or the child is in the parent\n */\n\n\nfunction isOrContainsNode(parent, child, environment) {\n  const result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);\n  return result;\n}\n/**\n * Simple debounce implementation. Will call the given\n * function once after the time given has passed since\n * it was last called.\n * @param {Function} fn the function to call after the time\n * @param {Number} time the time to wait\n * @return {Function} the debounced function\n */\n\n\nfunction debounce(fn, time) {\n  let timeoutId;\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cancel();\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      fn(...args);\n    }, time);\n  }\n\n  wrapper.cancel = cancel;\n  return wrapper;\n}\n/**\n * This is intended to be used to compose event handlers.\n * They are executed in order until one of them sets\n * `event.preventDownshiftDefault = true`.\n * @param {...Function} fns the event handler functions\n * @return {Function} the event handler to add to an element\n */\n\n\nfunction callAllEventHandlers() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return function (event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return fns.some(fn => {\n      if (fn) {\n        fn(event, ...args);\n      }\n\n      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;\n    });\n  };\n}\n\nfunction handleRefs() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n}\n/**\n * This generates a unique ID for an instance of Downshift\n * @return {String} the unique ID\n */\n\n\nfunction generateId() {\n  return String(idCounter++);\n}\n/**\n * Resets idCounter to 0. Used for SSR.\n */\n\n\nfunction resetIdCounter() {\n  idCounter = 0;\n}\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specify if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\n\n\nfunction getA11yStatusMessage$1(_ref2) {\n  let {\n    isOpen,\n    resultCount,\n    previousResultCount\n  } = _ref2;\n\n  if (!isOpen) {\n    return '';\n  }\n\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n\n  if (resultCount !== previousResultCount) {\n    return `${resultCount} result${resultCount === 1 ? ' is' : 's are'} available, use up and down arrow keys to navigate. Press Enter key to select.`;\n  }\n\n  return '';\n}\n/**\n * Takes an argument and if it's an array, returns the first item in the array\n * otherwise returns the argument\n * @param {*} arg the maybe-array\n * @param {*} defaultValue the value if arg is falsey not defined\n * @return {*} the arg or it's first item\n */\n\n\nfunction unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ?\n  /* istanbul ignore next (preact) */\n  arg[0] : arg;\n\n  if (!arg && defaultValue) {\n    return defaultValue;\n  } else {\n    return arg;\n  }\n}\n/**\n * @param {Object} element (P)react element\n * @return {Boolean} whether it's a DOM element\n */\n\n\nfunction isDOMElement(element) {\n\n\n  return typeof element.type === 'string';\n}\n/**\n * @param {Object} element (P)react element\n * @return {Object} the props\n */\n\n\nfunction getElementProps(element) {\n\n  return element.props;\n}\n/**\n * Throws a helpful error message for required properties. Useful\n * to be used as a default in destructuring or object params.\n * @param {String} fnName the function name\n * @param {String} propName the prop name\n */\n\n\nfunction requiredProp(fnName, propName) {\n  // eslint-disable-next-line no-console\n  console.error(`The property \"${propName}\" is required in \"${fnName}\"`);\n}\n\nconst stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];\n/**\n * @param {Object} state the state object\n * @return {Object} state that is relevant to downshift\n */\n\nfunction pickState(state) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  const result = {};\n  stateKeys.forEach(k => {\n    if (state.hasOwnProperty(k)) {\n      result[k] = state[k];\n    }\n  });\n  return result;\n}\n/**\n * This will perform a shallow merge of the given state object\n * with the state coming from props\n * (for the controlled component scenario)\n * This is used in state updater functions so they're referencing\n * the right state regardless of where it comes from.\n *\n * @param {Object} state The state of the component/hook.\n * @param {Object} props The props that may contain controlled values.\n * @returns {Object} The merged controlled state.\n */\n\n\nfunction getState(state, props) {\n  return Object.keys(state).reduce((prevState, key) => {\n    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];\n    return prevState;\n  }, {});\n}\n/**\n * This determines whether a prop is a \"controlled prop\" meaning it is\n * state which is controlled by the outside of this component rather\n * than within this component.\n *\n * @param {Object} props The props that may contain controlled values.\n * @param {String} key the key to check\n * @return {Boolean} whether it is a controlled controlled prop\n */\n\n\nfunction isControlledProp(props, key) {\n  return props[key] !== undefined;\n}\n/**\n * Normalizes the 'key' property of a KeyboardEvent in IE/Edge\n * @param {Object} event a keyboardEvent object\n * @return {String} keyboard key\n */\n\n\nfunction normalizeArrowKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  /* istanbul ignore next (ie) */\n\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {\n    return `Arrow${key}`;\n  }\n\n  return key;\n}\n/**\n * Simple check if the value passed is object literal\n * @param {*} obj any things\n * @return {Boolean} whether it's object literal\n */\n\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,\n * it will wrap to either 0 or itemCount - 1.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index after the move.\n */\n\n\nfunction getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  if (circular === void 0) {\n    circular = true;\n  }\n\n  if (itemCount === 0) {\n    return -1;\n  }\n\n  const itemsLastIndex = itemCount - 1;\n\n  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n\n  let newIndex = baseIndex + moveAmount;\n\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n\n  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n\n  return nonDisabledNewIndex;\n}\n/**\n * Returns the next index in the list of an item that is not disabled.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.\n */\n\n\nfunction getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n\n  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {\n    return baseIndex;\n  }\n\n  if (moveAmount > 0) {\n    for (let index = baseIndex + 1; index < itemCount; index++) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  } else {\n    for (let index = baseIndex - 1; index >= 0; index--) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  }\n\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n\n  return -1;\n}\n/**\n * Checks if event target is within the downshift elements.\n *\n * @param {EventTarget} target Target to check.\n * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).\n * @param {Window} environment The window context where downshift renders.\n * @param {boolean} checkActiveElement Whether to also check activeElement.\n *\n * @returns {boolean} Whether or not the target is within downshift elements.\n */\n\n\nfunction targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {\n  if (checkActiveElement === void 0) {\n    checkActiveElement = true;\n  }\n\n  return downshiftElements.some(contextNode => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validateControlledUnchanged = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validateControlledUnchanged = (state, prevProps, nextProps) => {\n    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;\n    Object.keys(state).forEach(propKey => {\n      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the controlled prop \"${propKey}\" to be uncontrolled. ${warningDescription}`);\n      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the uncontrolled prop \"${propKey}\" to be controlled. ${warningDescription}`);\n      }\n    });\n  };\n}\n\nconst cleanupStatus = debounce(documentProp => {\n  getStatusDiv(documentProp).textContent = '';\n}, 500);\n/**\n * @param {String} status the status message\n * @param {Object} documentProp document passed by the user.\n */\n\nfunction setStatus(status, documentProp) {\n  const div = getStatusDiv(documentProp);\n\n  if (!status) {\n    return;\n  }\n\n  div.textContent = status;\n  cleanupStatus(documentProp);\n}\n/**\n * Get the status node or create it if it does not already exist.\n * @param {Object} documentProp document passed by the user.\n * @return {HTMLElement} the status node.\n */\n\n\nfunction getStatusDiv(documentProp) {\n  if (documentProp === void 0) {\n    documentProp = document;\n  }\n\n  let statusDiv = documentProp.getElementById('a11y-status-message');\n\n  if (statusDiv) {\n    return statusDiv;\n  }\n\n  statusDiv = documentProp.createElement('div');\n  statusDiv.setAttribute('id', 'a11y-status-message');\n  statusDiv.setAttribute('role', 'status');\n  statusDiv.setAttribute('aria-live', 'polite');\n  statusDiv.setAttribute('aria-relevant', 'additions text');\n  Object.assign(statusDiv.style, {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    width: '1px'\n  });\n  documentProp.body.appendChild(statusDiv);\n  return statusDiv;\n}\n\nconst unknown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_unknown__' : 0;\nconst mouseUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_mouseup__' : 1;\nconst itemMouseEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_item_mouseenter__' : 2;\nconst keyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_up__' : 3;\nconst keyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_down__' : 4;\nconst keyDownEscape = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_escape__' : 5;\nconst keyDownEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_enter__' : 6;\nconst keyDownHome = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_home__' : 7;\nconst keyDownEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_end__' : 8;\nconst clickItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_item__' : 9;\nconst blurInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_input__' : 10;\nconst changeInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_change_input__' : 11;\nconst keyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_space_button__' : 12;\nconst clickButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_button__' : 13;\nconst blurButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_button__' : 14;\nconst controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;\nconst touchEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_touchend__' : 16;\n\nvar stateChangeTypes$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unknown: unknown,\n  mouseUp: mouseUp,\n  itemMouseEnter: itemMouseEnter,\n  keyDownArrowUp: keyDownArrowUp,\n  keyDownArrowDown: keyDownArrowDown,\n  keyDownEscape: keyDownEscape,\n  keyDownEnter: keyDownEnter,\n  keyDownHome: keyDownHome,\n  keyDownEnd: keyDownEnd,\n  clickItem: clickItem,\n  blurInput: blurInput,\n  changeInput: changeInput,\n  keyDownSpaceButton: keyDownSpaceButton,\n  clickButton: clickButton,\n  blurButton: blurButton,\n  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,\n  touchEnd: touchEnd\n});\n\n/* eslint camelcase:0 */\n\nconst Downshift = /*#__PURE__*/(() => {\n  class Downshift extends Component {\n    constructor(_props) {\n      var _this;\n\n      super(_props);\n      _this = this;\n      this.id = this.props.id || `downshift-${generateId()}`;\n      this.menuId = this.props.menuId || `${this.id}-menu`;\n      this.labelId = this.props.labelId || `${this.id}-label`;\n      this.inputId = this.props.inputId || `${this.id}-input`;\n\n      this.getItemId = this.props.getItemId || (index => `${this.id}-item-${index}`);\n\n      this.input = null;\n      this.items = [];\n      this.itemCount = null;\n      this.previousResultCount = 0;\n      this.timeoutIds = [];\n\n      this.internalSetTimeout = (fn, time) => {\n        const id = setTimeout(() => {\n          this.timeoutIds = this.timeoutIds.filter(i => i !== id);\n          fn();\n        }, time);\n        this.timeoutIds.push(id);\n      };\n\n      this.setItemCount = count => {\n        this.itemCount = count;\n      };\n\n      this.unsetItemCount = () => {\n        this.itemCount = null;\n      };\n\n      this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {\n        if (highlightedIndex === void 0) {\n          highlightedIndex = _this.props.defaultHighlightedIndex;\n        }\n\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState({\n          highlightedIndex,\n          ...otherStateToSet\n        });\n      };\n\n      this.clearSelection = cb => {\n        this.internalSetState({\n          selectedItem: null,\n          inputValue: '',\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          isOpen: this.props.defaultIsOpen\n        }, cb);\n      };\n\n      this.selectItem = (item, otherStateToSet, cb) => {\n        otherStateToSet = pickState(otherStateToSet);\n        this.internalSetState({\n          isOpen: this.props.defaultIsOpen,\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          selectedItem: item,\n          inputValue: this.props.itemToString(item),\n          ...otherStateToSet\n        }, cb);\n      };\n\n      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {\n        const item = this.items[itemIndex];\n\n        if (item == null) {\n          return;\n        }\n\n        this.selectItem(item, otherStateToSet, cb);\n      };\n\n      this.selectHighlightedItem = (otherStateToSet, cb) => {\n        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);\n      };\n\n      this.internalSetState = (stateToSet, cb) => {\n        let isItemSelected, onChangeArg;\n        const onStateChangeArg = {};\n        const isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call\n        // so someone controlling the `inputValue` state gets notified of\n        // the input change as soon as possible. This avoids issues with\n        // preserving the cursor position.\n        // See https://github.com/downshift-js/downshift/issues/217 for more info.\n\n        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {\n          this.props.onInputValueChange(stateToSet.inputValue, { ...this.getStateAndHelpers(),\n            ...stateToSet\n          });\n        }\n\n        return this.setState(state => {\n          state = this.getState(state);\n          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.\n\n          newStateToSet = this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from\n          // what was selected before\n          // used to determine if onSelect and onChange callbacks should be called\n\n          isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState\n\n          const nextState = {}; // this is just used to tell whether the state changed\n          // and we're trying to update that state. OR if the selection has changed and we're\n          // trying to update the selection\n\n          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\n            onChangeArg = newStateToSet.selectedItem;\n          }\n\n          newStateToSet.type = newStateToSet.type || unknown;\n          Object.keys(newStateToSet).forEach(key => {\n            // onStateChangeArg should only have the state that is\n            // actually changing\n            if (state[key] !== newStateToSet[key]) {\n              onStateChangeArg[key] = newStateToSet[key];\n            } // the type is useful for the onStateChangeArg\n            // but we don't actually want to set it in internal state.\n            // this is an undocumented feature for now... Not all internalSetState\n            // calls support it and I'm not certain we want them to yet.\n            // But it enables users controlling the isOpen state to know when\n            // the isOpen state changes due to mouseup events which is quite handy.\n\n\n            if (key === 'type') {\n              return;\n            }\n\n            newStateToSet[key]; // if it's coming from props, then we don't care to set it internally\n\n            if (!isControlledProp(this.props, key)) {\n              nextState[key] = newStateToSet[key];\n            }\n          }); // if stateToSet is a function, then we weren't able to call onInputValueChange\n          // earlier, so we'll call it now that we know what the inputValue state will be.\n\n          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {\n            this.props.onInputValueChange(newStateToSet.inputValue, { ...this.getStateAndHelpers(),\n              ...newStateToSet\n            });\n          }\n\n          return nextState;\n        }, () => {\n          // call the provided callback if it's a function\n          cbToCb(cb)(); // only call the onStateChange and onChange callbacks if\n          // we have relevant information to pass them.\n\n          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\n\n          if (hasMoreStateThanType) {\n            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());\n          }\n\n          if (isItemSelected) {\n            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());\n          }\n\n          if (onChangeArg !== undefined) {\n            this.props.onChange(onChangeArg, this.getStateAndHelpers());\n          } // this is currently undocumented and therefore subject to change\n          // We'll try to not break it, but just be warned.\n\n\n          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());\n        });\n      };\n\n      this.rootRef = node => this._rootNode = node;\n\n      this.getRootProps = function (_temp, _temp2) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...rest\n        } = _temp === void 0 ? {} : _temp;\n        let {\n          suppressRefError = false\n        } = _temp2 === void 0 ? {} : _temp2;\n        // this is used in the render to know whether the user has called getRootProps.\n        // It uses that to know whether to apply the props automatically\n        _this.getRootProps.called = true;\n        _this.getRootProps.refKey = refKey;\n        _this.getRootProps.suppressRefError = suppressRefError;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        return {\n          [refKey]: handleRefs(ref, _this.rootRef),\n          role: 'combobox',\n          'aria-expanded': isOpen,\n          'aria-haspopup': 'listbox',\n          'aria-owns': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          ...rest\n        };\n      };\n\n      this.keyDownHandlers = {\n        ArrowDown(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? 5 : 1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowDown\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowDown\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowDown\n                });\n              }\n            });\n          }\n        },\n\n        ArrowUp(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? -5 : -1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowUp\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowUp\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowUp\n                });\n              }\n            });\n          }\n        },\n\n        Enter(event) {\n          if (event.which === 229) {\n            return;\n          }\n\n          const {\n            isOpen,\n            highlightedIndex\n          } = this.getState();\n\n          if (isOpen && highlightedIndex != null) {\n            event.preventDefault();\n            const item = this.items[highlightedIndex];\n            const itemNode = this.getItemNodeFromIndex(highlightedIndex);\n\n            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {\n              return;\n            }\n\n            this.selectHighlightedItem({\n              type: keyDownEnter\n            });\n          }\n        },\n\n        Escape(event) {\n          event.preventDefault();\n          this.reset({\n            type: keyDownEscape,\n            ...(!this.state.isOpen && {\n              selectedItem: null,\n              inputValue: ''\n            })\n          });\n        }\n\n      };\n      this.buttonKeyDownHandlers = { ...this.keyDownHandlers,\n\n        ' '(event) {\n          event.preventDefault();\n          this.toggleMenu({\n            type: keyDownSpaceButton\n          });\n        }\n\n      };\n      this.inputKeyDownHandlers = { ...this.keyDownHandlers,\n\n        Home(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting downwards from 0 if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownHome\n          });\n        },\n\n        End(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting upwards from last index if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownEnd\n          });\n        }\n\n      };\n\n      this.getToggleButtonProps = function (_temp3) {\n        let {\n          onClick,\n          onPress,\n          onKeyDown,\n          onKeyUp,\n          onBlur,\n          ...rest\n        } = _temp3 === void 0 ? {} : _temp3;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        const enabledEventHandlers = {\n          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),\n          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),\n          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),\n          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)\n        };\n        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;\n        return {\n          type: 'button',\n          role: 'button',\n          'aria-label': isOpen ? 'close menu' : 'open menu',\n          'aria-haspopup': true,\n          'data-toggle': true,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.buttonHandleKeyUp = event => {\n        // Prevent click event from emitting in Firefox\n        event.preventDefault();\n      };\n\n      this.buttonHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (this.buttonKeyDownHandlers[key]) {\n          this.buttonKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.buttonHandleClick = event => {\n        event.preventDefault(); // handle odd case for Safari and Firefox which\n        // don't give the button the focus properly.\n\n        /* istanbul ignore if (can't reasonably test this) */\n\n        if (this.props.environment.document.activeElement === this.props.environment.document.body) {\n          event.target.focus();\n        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout\n        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated\n        // when building for production and should therefore have no impact on production code.\n\n\n        if (process.env.NODE_ENV === 'test') {\n          this.toggleMenu({\n            type: clickButton\n          });\n        } else {\n          // Ensure that toggle of menu occurs after the potential blur event in iOS\n          this.internalSetTimeout(() => this.toggleMenu({\n            type: clickButton\n          }));\n        }\n      };\n\n      this.buttonHandleBlur = event => {\n        const blurTarget = event.target; // Save blur target for comparison with activeElement later\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element\n\n        this.internalSetTimeout(() => {\n          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)\n          ) {\n            this.reset({\n              type: blurButton\n            });\n          }\n        });\n      };\n\n      this.getLabelProps = props => {\n        return {\n          htmlFor: this.inputId,\n          id: this.labelId,\n          ...props\n        };\n      };\n\n      this.getInputProps = function (_temp4) {\n        let {\n          onKeyDown,\n          onBlur,\n          onChange,\n          onInput,\n          onChangeText,\n          ...rest\n        } = _temp4 === void 0 ? {} : _temp4;\n        let onChangeKey;\n        let eventHandlers = {};\n        /* istanbul ignore next (preact) */\n\n        {\n          onChangeKey = 'onChange';\n        }\n\n        const {\n          inputValue,\n          isOpen,\n          highlightedIndex\n        } = _this.getState();\n\n        if (!rest.disabled) {\n          eventHandlers = {\n            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),\n            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),\n            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)\n          };\n        }\n\n        return {\n          'aria-autocomplete': 'list',\n          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\n          'aria-controls': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n          // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n          autoComplete: 'off',\n          value: inputValue,\n          id: _this.inputId,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.inputHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (key && this.inputKeyDownHandlers[key]) {\n          this.inputKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.inputHandleChange = event => {\n        this.internalSetState({\n          type: changeInput,\n          isOpen: true,\n          inputValue: event.target.value,\n          highlightedIndex: this.props.defaultHighlightedIndex\n        });\n      };\n\n      this.inputHandleBlur = () => {\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element\n        this.internalSetTimeout(() => {\n          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);\n\n          if (!this.isMouseDown && !downshiftButtonIsActive) {\n            this.reset({\n              type: blurInput\n            });\n          }\n        });\n      };\n\n      this.menuRef = node => {\n        this._menuNode = node;\n      };\n\n      this.getMenuProps = function (_temp5, _temp6) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...props\n        } = _temp5 === void 0 ? {} : _temp5;\n        let {\n          suppressRefError = false\n        } = _temp6 === void 0 ? {} : _temp6;\n        _this.getMenuProps.called = true;\n        _this.getMenuProps.refKey = refKey;\n        _this.getMenuProps.suppressRefError = suppressRefError;\n        return {\n          [refKey]: handleRefs(ref, _this.menuRef),\n          role: 'listbox',\n          'aria-labelledby': props && props['aria-label'] ? null : _this.labelId,\n          id: _this.menuId,\n          ...props\n        };\n      };\n\n      this.getItemProps = function (_temp7) {\n        let {\n          onMouseMove,\n          onMouseDown,\n          onClick,\n          onPress,\n          index,\n          item = process.env.NODE_ENV === 'production' ?\n          /* istanbul ignore next */\n          undefined : requiredProp('getItemProps', 'item'),\n          ...rest\n        } = _temp7 === void 0 ? {} : _temp7;\n\n        if (index === undefined) {\n          _this.items.push(item);\n\n          index = _this.items.indexOf(item);\n        } else {\n          _this.items[index] = item;\n        }\n\n        const onSelectKey = 'onClick';\n        const customClickHandler = onClick;\n        const enabledEventHandlers = {\n          // onMouseMove is used over onMouseEnter here. onMouseMove\n          // is only triggered on actual mouse movement while onMouseEnter\n          // can fire on DOM changes, interrupting keyboard navigation\n          onMouseMove: callAllEventHandlers(onMouseMove, () => {\n            if (index === _this.getState().highlightedIndex) {\n              return;\n            }\n\n            _this.setHighlightedIndex(index, {\n              type: itemMouseEnter\n            }); // We never want to manually scroll when changing state based\n            // on `onMouseMove` because we will be moving the element out\n            // from under the user which is currently scrolling/moving the\n            // cursor\n\n\n            _this.avoidScrolling = true;\n\n            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);\n          }),\n          onMouseDown: callAllEventHandlers(onMouseDown, event => {\n            // This prevents the activeElement from being changed\n            // to the item so it can remain with the current activeElement\n            // which is a more common use case.\n            event.preventDefault();\n          }),\n          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {\n            _this.selectItemAtIndex(index, {\n              type: clickItem\n            });\n          })\n        }; // Passing down the onMouseDown handler to prevent redirect\n        // of the activeElement if clicking on disabled items\n\n        const eventHandlers = rest.disabled ? {\n          onMouseDown: enabledEventHandlers.onMouseDown\n        } : enabledEventHandlers;\n        return {\n          id: _this.getItemId(index),\n          role: 'option',\n          'aria-selected': _this.getState().highlightedIndex === index,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.clearItems = () => {\n        this.items = [];\n      };\n\n      this.reset = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref => {\n          let {\n            selectedItem\n          } = _ref;\n          return {\n            isOpen: _this.props.defaultIsOpen,\n            highlightedIndex: _this.props.defaultHighlightedIndex,\n            inputValue: _this.props.itemToString(selectedItem),\n            ...otherStateToSet\n          };\n        }, cb);\n      };\n\n      this.toggleMenu = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref2 => {\n          let {\n            isOpen\n          } = _ref2;\n          return {\n            isOpen: !isOpen,\n            ...(isOpen && {\n              highlightedIndex: _this.props.defaultHighlightedIndex\n            }),\n            ...otherStateToSet\n          };\n        }, () => {\n          const {\n            isOpen,\n            highlightedIndex\n          } = _this.getState();\n\n          if (isOpen) {\n            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {\n              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);\n            }\n          }\n\n          cbToCb(cb)();\n        });\n      };\n\n      this.openMenu = cb => {\n        this.internalSetState({\n          isOpen: true\n        }, cb);\n      };\n\n      this.closeMenu = cb => {\n        this.internalSetState({\n          isOpen: false\n        }, cb);\n      };\n\n      this.updateStatus = debounce(() => {\n        const state = this.getState();\n        const item = this.items[state.highlightedIndex];\n        const resultCount = this.getItemCount();\n        const status = this.props.getA11yStatusMessage({\n          itemToString: this.props.itemToString,\n          previousResultCount: this.previousResultCount,\n          resultCount,\n          highlightedItem: item,\n          ...state\n        });\n        this.previousResultCount = resultCount;\n        setStatus(status, this.props.environment.document);\n      }, 200);\n      // fancy destructuring + defaults + aliases\n      // this basically says each value of state should either be set to\n      // the initial value or the default value if the initial value is not provided\n      const {\n        defaultHighlightedIndex,\n        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,\n        defaultIsOpen,\n        initialIsOpen: _isOpen = defaultIsOpen,\n        initialInputValue: _inputValue = '',\n        initialSelectedItem: _selectedItem = null\n      } = this.props;\n\n      const _state = this.getState({\n        highlightedIndex: _highlightedIndex,\n        isOpen: _isOpen,\n        inputValue: _inputValue,\n        selectedItem: _selectedItem\n      });\n\n      if (_state.selectedItem != null && this.props.initialInputValue === undefined) {\n        _state.inputValue = this.props.itemToString(_state.selectedItem);\n      }\n\n      this.state = _state;\n    }\n\n    /**\n     * Clear all running timeouts\n     */\n    internalClearTimeouts() {\n      this.timeoutIds.forEach(id => {\n        clearTimeout(id);\n      });\n      this.timeoutIds = [];\n    }\n    /**\n     * Gets the state based on internal state or props\n     * If a state value is passed via props, then that\n     * is the value given, otherwise it's retrieved from\n     * stateToMerge\n     *\n     * @param {Object} stateToMerge defaults to this.state\n     * @return {Object} the state\n     */\n\n\n    getState(stateToMerge) {\n      if (stateToMerge === void 0) {\n        stateToMerge = this.state;\n      }\n\n      return getState(stateToMerge, this.props);\n    }\n\n    getItemCount() {\n      // things read better this way. They're in priority order:\n      // 1. `this.itemCount`\n      // 2. `this.props.itemCount`\n      // 3. `this.items.length`\n      let itemCount = this.items.length;\n\n      if (this.itemCount != null) {\n        itemCount = this.itemCount;\n      } else if (this.props.itemCount !== undefined) {\n        itemCount = this.props.itemCount;\n      }\n\n      return itemCount;\n    }\n\n    getItemNodeFromIndex(index) {\n      return this.props.environment.document.getElementById(this.getItemId(index));\n    }\n\n    scrollHighlightedItemIntoView() {\n      /* istanbul ignore else (react-native) */\n      {\n        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\n        this.props.scrollIntoView(node, this._menuNode);\n      }\n    }\n\n    moveHighlightedIndex(amount, otherStateToSet) {\n      const itemCount = this.getItemCount();\n      const {\n        highlightedIndex\n      } = this.getState();\n\n      if (itemCount > 0) {\n        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);\n      }\n    }\n\n    getStateAndHelpers() {\n      const {\n        highlightedIndex,\n        inputValue,\n        selectedItem,\n        isOpen\n      } = this.getState();\n      const {\n        itemToString\n      } = this.props;\n      const {\n        id\n      } = this;\n      const {\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        reset,\n        setItemCount,\n        unsetItemCount,\n        internalSetState: setState\n      } = this;\n      return {\n        // prop getters\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        // actions\n        reset,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        setItemCount,\n        unsetItemCount,\n        setState,\n        // props\n        itemToString,\n        // derived\n        id,\n        // state\n        highlightedIndex,\n        inputValue,\n        isOpen,\n        selectedItem\n      };\n    } //////////////////////////// ROOT\n\n\n    componentDidMount() {\n      /* istanbul ignore if (react-native) */\n      if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n      }\n      /* istanbul ignore if (react-native) */\n\n\n      {\n        // this.isMouseDown helps us track whether the mouse is currently held down.\n        // This is useful when the user clicks on an item in the list, but holds the mouse\n        // down long enough for the list to disappear (because the blur event fires on the input)\n        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should\n        // trigger hiding the menu.\n        const onMouseDown = () => {\n          this.isMouseDown = true;\n        };\n\n        const onMouseUp = event => {\n          this.isMouseDown = false; // if the target element or the activeElement is within a downshift node\n          // then we don't want to reset downshift\n\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);\n\n          if (!contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: mouseUp\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        }; // Touching an element in iOS gives focus and hover states, but touching out of\n        // the element will remove hover, and persist the focus state, resulting in the\n        // blur event not being triggered.\n        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.\n        // If the user taps outside of Downshift, the component should be reset,\n        // but not if the user is swiping\n\n\n        const onTouchStart = () => {\n          this.isTouchMove = false;\n        };\n\n        const onTouchMove = () => {\n          this.isTouchMove = true;\n        };\n\n        const onTouchEnd = event => {\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);\n\n          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: touchEnd\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n\n        const {\n          environment\n        } = this.props;\n        environment.addEventListener('mousedown', onMouseDown);\n        environment.addEventListener('mouseup', onMouseUp);\n        environment.addEventListener('touchstart', onTouchStart);\n        environment.addEventListener('touchmove', onTouchMove);\n        environment.addEventListener('touchend', onTouchEnd);\n\n        this.cleanup = () => {\n          this.internalClearTimeouts();\n          this.updateStatus.cancel();\n          environment.removeEventListener('mousedown', onMouseDown);\n          environment.removeEventListener('mouseup', onMouseUp);\n          environment.removeEventListener('touchstart', onTouchStart);\n          environment.removeEventListener('touchmove', onTouchMove);\n          environment.removeEventListener('touchend', onTouchEnd);\n        };\n      }\n    }\n\n    shouldScroll(prevState, prevProps) {\n      const {\n        highlightedIndex: currentHighlightedIndex\n      } = this.props.highlightedIndex === undefined ? this.getState() : this.props;\n      const {\n        highlightedIndex: prevHighlightedIndex\n      } = prevProps.highlightedIndex === undefined ? prevState : prevProps;\n      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;\n      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;\n      return scrollWhenOpen || scrollWhenNavigating;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateControlledUnchanged(this.state, prevProps, this.props);\n        /* istanbul ignore if (react-native) */\n\n        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n        }\n      }\n\n      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\n        this.internalSetState({\n          type: controlledPropUpdatedSelectedItem,\n          inputValue: this.props.itemToString(this.props.selectedItem)\n        });\n      }\n\n      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {\n        this.scrollHighlightedItemIntoView();\n      }\n      /* istanbul ignore else (react-native) */\n\n\n      {\n        this.updateStatus();\n      }\n    }\n\n    componentWillUnmount() {\n      this.cleanup(); // avoids memory leak\n    }\n\n    render() {\n      const children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children\n      // we clear this out each render and it will be populated again as\n      // getItemProps is called.\n\n      this.clearItems(); // we reset this so we know whether the user calls getRootProps during\n      // this render. If they do then we don't need to do anything,\n      // if they don't then we need to clone the element they return and\n      // apply the props for them.\n\n      this.getRootProps.called = false;\n      this.getRootProps.refKey = undefined;\n      this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps\n\n      this.getMenuProps.called = false;\n      this.getMenuProps.refKey = undefined;\n      this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps\n\n      this.getLabelProps.called = false; // and something similar for getInputProps\n\n      this.getInputProps.called = false;\n      const element = unwrapArray(children(this.getStateAndHelpers()));\n\n      if (!element) {\n        return null;\n      }\n\n      if (this.getRootProps.called || this.props.suppressRefError) {\n        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {\n          validateGetRootPropsCalledCorrectly(element, this.getRootProps);\n        }\n\n        return element;\n      } else if (isDOMElement(element)) {\n        // they didn't apply the root props, but we can clone\n        // this and apply the props ourselves\n        return /*#__PURE__*/cloneElement(element, this.getRootProps(getElementProps(element)));\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        // they didn't apply the root props, but they need to\n        // otherwise we can't query around the autocomplete\n        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');\n      }\n      /* istanbul ignore next */\n\n\n      return undefined;\n    }\n\n  }\n\n  Downshift.defaultProps = {\n    defaultHighlightedIndex: null,\n    defaultIsOpen: false,\n    getA11yStatusMessage: getA11yStatusMessage$1,\n    itemToString: i => {\n      if (i == null) {\n        return '';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {\n        // eslint-disable-next-line no-console\n        console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);\n      }\n\n      return String(i);\n    },\n    onStateChange: noop,\n    onInputValueChange: noop,\n    onUserAction: noop,\n    onChange: noop,\n    onSelect: noop,\n    onOuterClick: noop,\n    selectedItemChanged: (prevItem, item) => prevItem !== item,\n    environment:\n    /* istanbul ignore next (ssr) */\n    typeof window === 'undefined' ? {} : window,\n    stateReducer: (state, stateToSet) => stateToSet,\n    suppressRefError: false,\n    scrollIntoView\n  };\n  Downshift.stateChangeTypes = stateChangeTypes$3;\n  return Downshift;\n})();\n\nprocess.env.NODE_ENV !== \"production\" ? Downshift.propTypes = {\n  children: PropTypes.func,\n  defaultHighlightedIndex: PropTypes.number,\n  defaultIsOpen: PropTypes.bool,\n  initialHighlightedIndex: PropTypes.number,\n  initialSelectedItem: PropTypes.any,\n  initialInputValue: PropTypes.string,\n  initialIsOpen: PropTypes.bool,\n  getA11yStatusMessage: PropTypes.func,\n  itemToString: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  onUserAction: PropTypes.func,\n  onOuterClick: PropTypes.func,\n  selectedItemChanged: PropTypes.func,\n  stateReducer: PropTypes.func,\n  itemCount: PropTypes.number,\n  id: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  }),\n  suppressRefError: PropTypes.bool,\n  scrollIntoView: PropTypes.func,\n  // things we keep in state for uncontrolled components\n  // but can accept as props for controlled components\n\n  /* eslint-disable react/no-unused-prop-types */\n  selectedItem: PropTypes.any,\n  isOpen: PropTypes.bool,\n  inputValue: PropTypes.string,\n  highlightedIndex: PropTypes.number,\n  labelId: PropTypes.string,\n  inputId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func\n  /* eslint-enable react/no-unused-prop-types */\n\n} : void 0;\nvar Downshift$1 = Downshift;\n\nfunction validateGetMenuPropsCalledCorrectly(node, _ref3) {\n  let {\n    refKey\n  } = _ref3;\n\n  if (!node) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: The ref prop \"${refKey}\" from getMenuProps was not applied correctly on your menu element.`);\n  }\n}\n\nfunction validateGetRootPropsCalledCorrectly(element, _ref4) {\n  let {\n    refKey\n  } = _ref4;\n  const refKeySpecified = refKey !== 'ref';\n  const isComposite = !isDOMElement(element);\n\n  if (isComposite && !refKeySpecified && !isForwardRef(element)) {\n    // eslint-disable-next-line no-console\n    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');\n  } else if (!isComposite && refKeySpecified) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"${refKey}\"`);\n  }\n\n  if (!isForwardRef(element) && !getElementProps(element)[refKey]) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You must apply the ref prop \"${refKey}\" from getRootProps onto your root element.`);\n  }\n}\n\nconst dropdownDefaultStateValues = {\n  highlightedIndex: -1,\n  isOpen: false,\n  selectedItem: null,\n  inputValue: ''\n};\n\nfunction callOnChangeProps(action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const changes = {};\n  Object.keys(state).forEach(key => {\n    invokeOnChangeHandler(key, action, state, newState);\n\n    if (newState[key] !== state[key]) {\n      changes[key] = newState[key];\n    }\n  });\n\n  if (props.onStateChange && Object.keys(changes).length) {\n    props.onStateChange({\n      type,\n      ...changes\n    });\n  }\n}\n\nfunction invokeOnChangeHandler(key, action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const handler = `on${capitalizeString(key)}Change`;\n\n  if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {\n    props[handler]({\n      type,\n      ...newState\n    });\n  }\n}\n/**\n * Default state reducer that returns the changes.\n *\n * @param {Object} s state.\n * @param {Object} a action with changes.\n * @returns {Object} changes.\n */\n\n\nfunction stateReducer(s, a) {\n  return a.changes;\n}\n/**\n * Returns a message to be added to aria-live region when item is selected.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11ySelectionMessage(selectionParameters) {\n  const {\n    selectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : '';\n}\n/**\n * Debounced call for updating the a11y message.\n */\n\n\nconst updateA11yStatus = debounce((getA11yMessage, document) => {\n  setStatus(getA11yMessage(), document);\n}, 200); // istanbul ignore next\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction useElementIds(_ref) {\n  let {\n    id = `downshift-${generateId()}`,\n    labelId,\n    menuId,\n    getItemId,\n    toggleButtonId,\n    inputId\n  } = _ref;\n  const elementIdsRef = useRef({\n    labelId: labelId || `${id}-label`,\n    menuId: menuId || `${id}-menu`,\n    getItemId: getItemId || (index => `${id}-item-${index}`),\n    toggleButtonId: toggleButtonId || `${id}-toggle-button`,\n    inputId: inputId || `${id}-input`\n  });\n  return elementIdsRef.current;\n}\n\nfunction getItemIndex(index, item, items) {\n  if (index !== undefined) {\n    return index;\n  }\n\n  if (items.length === 0) {\n    return -1;\n  }\n\n  return items.indexOf(item);\n}\n\nfunction itemToString(item) {\n  return item ? String(item) : '';\n}\n\nfunction isAcceptedCharacterKey(key) {\n  return /^\\S{1}$/.test(key);\n}\n\nfunction capitalizeString(string) {\n  return `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`;\n}\n\nfunction useLatestRef(val) {\n  const ref = useRef(val); // technically this is not \"concurrent mode safe\" because we're manipulating\n  // the value during render (so it's not idempotent). However, the places this\n  // hook is used is to support memoizing callbacks which will be called\n  // *during* render, so we need the latest values *during* render.\n  // If not for this, then we'd probably want to use useLayoutEffect instead.\n\n  ref.current = val;\n  return ref;\n}\n/**\n * Computes the controlled state using a the previous state, props,\n * two reducers, one from downshift and an optional one from the user.\n * Also calls the onChange handlers for state values that have changed.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useEnhancedReducer(reducer, initialState, props) {\n  const prevStateRef = useRef();\n  const actionRef = useRef();\n  const enhancedReducer = useCallback((state, action) => {\n    actionRef.current = action;\n    state = getState(state, action.props);\n    const changes = reducer(state, action);\n    const newState = action.props.stateReducer(state, { ...action,\n      changes\n    });\n    return newState;\n  }, [reducer]);\n  const [state, dispatch] = useReducer(enhancedReducer, initialState);\n  const propsRef = useLatestRef(props);\n  const dispatchWithProps = useCallback(action => dispatch({\n    props: propsRef.current,\n    ...action\n  }), [propsRef]);\n  const action = actionRef.current;\n  useEffect(() => {\n    if (action && prevStateRef.current && prevStateRef.current !== state) {\n      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);\n    }\n\n    prevStateRef.current = state;\n  }, [state, props, action]);\n  return [state, dispatchWithProps];\n}\n/**\n * Wraps the useEnhancedReducer and applies the controlled prop values before\n * returning the new state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useControlledReducer$1(reducer, initialState, props) {\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props);\n  return [getState(state, props), dispatch];\n}\n\nconst defaultProps$3 = {\n  itemToString,\n  stateReducer,\n  getA11ySelectionMessage,\n  scrollIntoView,\n  circularNavigation: false,\n  environment:\n  /* istanbul ignore next (ssr) */\n  typeof window === 'undefined' ? {} : window\n};\n\nfunction getDefaultValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const defaultValue = props[`default${capitalizeString(propKey)}`];\n\n  if (defaultValue !== undefined) {\n    return defaultValue;\n  }\n\n  return defaultStateValues[propKey];\n}\n\nfunction getInitialValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const value = props[propKey];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  const initialValue = props[`initial${capitalizeString(propKey)}`];\n\n  if (initialValue !== undefined) {\n    return initialValue;\n  }\n\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n\nfunction getInitialState$2(props) {\n  const selectedItem = getInitialValue$1(props, 'selectedItem');\n  const isOpen = getInitialValue$1(props, 'isOpen');\n  const highlightedIndex = getInitialValue$1(props, 'highlightedIndex');\n  const inputValue = getInitialValue$1(props, 'inputValue');\n  return {\n    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nfunction getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {\n  const {\n    items,\n    initialHighlightedIndex,\n    defaultHighlightedIndex\n  } = props;\n  const {\n    selectedItem,\n    highlightedIndex\n  } = state;\n\n  if (items.length === 0) {\n    return -1;\n  } // initialHighlightedIndex will give value to highlightedIndex on initial state only.\n\n\n  if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {\n    return initialHighlightedIndex;\n  }\n\n  if (defaultHighlightedIndex !== undefined) {\n    return defaultHighlightedIndex;\n  }\n\n  if (selectedItem) {\n    if (offset === 0) {\n      return items.indexOf(selectedItem);\n    }\n\n    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);\n  }\n\n  if (offset === 0) {\n    return -1;\n  }\n\n  return offset < 0 ? items.length - 1 : 0;\n}\n/**\n * Reuse the movement tracking of mouse and touch events.\n *\n * @param {boolean} isOpen Whether the dropdown is open or not.\n * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)\n * @param {Object} environment Environment where component/hook exists.\n * @param {Function} handleBlur Handler on blur from mouse or touch.\n * @returns {Object} Ref containing whether mouseDown or touchMove event is happening\n */\n\n\nfunction useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {\n  const mouseAndTouchTrackersRef = useRef({\n    isMouseDown: false,\n    isTouchMove: false\n  });\n  useEffect(() => {\n    // The same strategy for checking if a click occurred inside or outside downsift\n    // as in downshift.js.\n    const onMouseDown = () => {\n      mouseAndTouchTrackersRef.current.isMouseDown = true;\n    };\n\n    const onMouseUp = event => {\n      mouseAndTouchTrackersRef.current.isMouseDown = false;\n\n      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment)) {\n        handleBlur();\n      }\n    };\n\n    const onTouchStart = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = false;\n    };\n\n    const onTouchMove = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = true;\n    };\n\n    const onTouchEnd = event => {\n      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment, false)) {\n        handleBlur();\n      }\n    };\n\n    environment.addEventListener('mousedown', onMouseDown);\n    environment.addEventListener('mouseup', onMouseUp);\n    environment.addEventListener('touchstart', onTouchStart);\n    environment.addEventListener('touchmove', onTouchMove);\n    environment.addEventListener('touchend', onTouchEnd);\n    return function cleanup() {\n      environment.removeEventListener('mousedown', onMouseDown);\n      environment.removeEventListener('mouseup', onMouseUp);\n      environment.removeEventListener('touchstart', onTouchStart);\n      environment.removeEventListener('touchmove', onTouchMove);\n      environment.removeEventListener('touchend', onTouchEnd);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, environment]);\n  return mouseAndTouchTrackersRef;\n}\n/* istanbul ignore next */\n// eslint-disable-next-line import/no-mutable-exports\n\n\nlet useGetterPropsCalledChecker = () => noop;\n/**\n * Custom hook that checks if getter props are called correctly.\n *\n * @param  {...any} propKeys Getter prop names to be handled.\n * @returns {Function} Setter function called inside getter props to set call information.\n */\n\n/* istanbul ignore next */\n\n\nif (process.env.NODE_ENV !== 'production') {\n  useGetterPropsCalledChecker = function () {\n    const isInitialMountRef = useRef(true);\n\n    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {\n      propKeys[_key] = arguments[_key];\n    }\n\n    const getterPropsCalledRef = useRef(propKeys.reduce((acc, propKey) => {\n      acc[propKey] = {};\n      return acc;\n    }, {}));\n    useEffect(() => {\n      Object.keys(getterPropsCalledRef.current).forEach(propKey => {\n        const propCallInfo = getterPropsCalledRef.current[propKey];\n\n        if (isInitialMountRef.current) {\n          if (!Object.keys(propCallInfo).length) {\n            // eslint-disable-next-line no-console\n            console.error(`downshift: You forgot to call the ${propKey} getter function on your component / element.`);\n            return;\n          }\n        }\n\n        const {\n          suppressRefError,\n          refKey,\n          elementRef\n        } = propCallInfo;\n\n        if ((!elementRef || !elementRef.current) && !suppressRefError) {\n          // eslint-disable-next-line no-console\n          console.error(`downshift: The ref prop \"${refKey}\" from ${propKey} was not applied correctly on your element.`);\n        }\n      });\n      isInitialMountRef.current = false;\n    });\n    const setGetterPropCallInfo = useCallback((propKey, suppressRefError, refKey, elementRef) => {\n      getterPropsCalledRef.current[propKey] = {\n        suppressRefError,\n        refKey,\n        elementRef\n      };\n    }, []);\n    return setGetterPropCallInfo;\n  };\n}\n\nfunction useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {\n  let {\n    isInitialMount,\n    highlightedIndex,\n    items,\n    environment,\n    ...rest\n  } = _ref2;\n  // Sets a11y status message on changes in state.\n  useEffect(() => {\n    if (isInitialMount || false) {\n      return;\n    }\n\n    updateA11yStatus(() => getA11yMessage({\n      highlightedIndex,\n      highlightedItem: items[highlightedIndex],\n      resultCount: items.length,\n      ...rest\n    }), environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencyArray);\n}\n\nfunction useScrollIntoView(_ref3) {\n  let {\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    getItemNodeFromIndex,\n    menuElement,\n    scrollIntoView: scrollIntoViewProp\n  } = _ref3;\n  // used not to scroll on highlight by mouse.\n  const shouldScrollRef = useRef(true); // Scroll on highlighted item if change comes from keyboard.\n\n  useIsomorphicLayoutEffect(() => {\n    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {\n      return;\n    }\n\n    if (shouldScrollRef.current === false) {\n      shouldScrollRef.current = true;\n    } else {\n      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [highlightedIndex]);\n  return shouldScrollRef;\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet useControlPropsValidator = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  useControlPropsValidator = _ref4 => {\n    let {\n      isInitialMount,\n      props,\n      state\n    } = _ref4;\n    // used for checking when props are moving from controlled to uncontrolled.\n    const prevPropsRef = useRef(props);\n    useEffect(() => {\n      if (isInitialMount) {\n        return;\n      }\n\n      validateControlledUnchanged(state, prevPropsRef.current, props);\n      prevPropsRef.current = props;\n    }, [state, props, isInitialMount]);\n  };\n}\n\n/* eslint-disable complexity */\n\nfunction downshiftCommonReducer(state, action, stateChangeTypes) {\n  const {\n    type,\n    props\n  } = action;\n  let changes;\n\n  switch (type) {\n    case stateChangeTypes.ItemMouseMove:\n      changes = {\n        highlightedIndex: action.disabled ? -1 : action.index\n      };\n      break;\n\n    case stateChangeTypes.MenuMouseLeave:\n      changes = {\n        highlightedIndex: -1\n      };\n      break;\n\n    case stateChangeTypes.ToggleButtonClick:\n    case stateChangeTypes.FunctionToggleMenu:\n      changes = {\n        isOpen: !state.isOpen,\n        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionOpenMenu:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionCloseMenu:\n      changes = {\n        isOpen: false\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetHighlightedIndex:\n      changes = {\n        highlightedIndex: action.highlightedIndex\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetInputValue:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    case stateChangeTypes.FunctionReset:\n      changes = {\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        selectedItem: getDefaultValue$1(props, 'selectedItem'),\n        inputValue: getDefaultValue$1(props, 'inputValue')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\nfunction getItemIndexByCharacterKey(_a) {\n    var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString = _a.itemToString, getItemNodeFromIndex = _a.getItemNodeFromIndex;\n    var lowerCasedKeysSoFar = keysSoFar.toLowerCase();\n    for (var index = 0; index < items.length; index++) {\n        var offsetIndex = (index + highlightedIndex + 1) % items.length;\n        var item = items[offsetIndex];\n        if (item !== undefined &&\n            itemToString(item)\n                .toLowerCase()\n                .startsWith(lowerCasedKeysSoFar)) {\n            var element = getItemNodeFromIndex(offsetIndex);\n            if (!(element === null || element === void 0 ? void 0 : element.hasAttribute('disabled'))) {\n                return offsetIndex;\n            }\n        }\n    }\n    return highlightedIndex;\n}\nvar propTypes$2 = {\n    items: PropTypes.array.isRequired,\n    itemToString: PropTypes.func,\n    getA11yStatusMessage: PropTypes.func,\n    getA11ySelectionMessage: PropTypes.func,\n    circularNavigation: PropTypes.bool,\n    highlightedIndex: PropTypes.number,\n    defaultHighlightedIndex: PropTypes.number,\n    initialHighlightedIndex: PropTypes.number,\n    isOpen: PropTypes.bool,\n    defaultIsOpen: PropTypes.bool,\n    initialIsOpen: PropTypes.bool,\n    selectedItem: PropTypes.any,\n    initialSelectedItem: PropTypes.any,\n    defaultSelectedItem: PropTypes.any,\n    id: PropTypes.string,\n    labelId: PropTypes.string,\n    menuId: PropTypes.string,\n    getItemId: PropTypes.func,\n    toggleButtonId: PropTypes.string,\n    stateReducer: PropTypes.func,\n    onSelectedItemChange: PropTypes.func,\n    onHighlightedIndexChange: PropTypes.func,\n    onStateChange: PropTypes.func,\n    onIsOpenChange: PropTypes.func,\n    environment: PropTypes.shape({\n        addEventListener: PropTypes.func,\n        removeEventListener: PropTypes.func,\n        document: PropTypes.shape({\n            getElementById: PropTypes.func,\n            activeElement: PropTypes.any,\n            body: PropTypes.any\n        })\n    })\n};\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specift if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\nfunction getA11yStatusMessage(_a) {\n    var isOpen = _a.isOpen, resultCount = _a.resultCount, previousResultCount = _a.previousResultCount;\n    if (!isOpen) {\n        return '';\n    }\n    if (!resultCount) {\n        return 'No results are available.';\n    }\n    if (resultCount !== previousResultCount) {\n        return \"\".concat(resultCount, \" result\").concat(resultCount === 1 ? ' is' : 's are', \" available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.\");\n    }\n    return '';\n}\nvar defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage: getA11yStatusMessage });\n// eslint-disable-next-line import/no-mutable-exports\nvar validatePropTypes$2 = noop;\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    validatePropTypes$2 = function (options, caller) {\n        PropTypes.checkPropTypes(propTypes$2, options, 'prop', caller.name);\n    };\n}\n\nconst MenuKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_down__' : 0;\nconst MenuKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_up__' : 1;\nconst MenuKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_escape__' : 2;\nconst MenuKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_home__' : 3;\nconst MenuKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_end__' : 4;\nconst MenuKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_enter__' : 5;\nconst MenuKeyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_space_button__' : 6;\nconst MenuKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_character__' : 7;\nconst MenuBlur = process.env.NODE_ENV !== \"production\" ? '__menu_blur__' : 8;\nconst MenuMouseLeave$1 = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 9;\nconst ItemMouseMove$1 = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 10;\nconst ItemClick$1 = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 11;\nconst ToggleButtonClick$1 = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 12;\nconst ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_down__' : 13;\nconst ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_up__' : 14;\nconst ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_character__' : 15;\nconst FunctionToggleMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 16;\nconst FunctionOpenMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 17;\nconst FunctionCloseMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 18;\nconst FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 19;\nconst FunctionSelectItem$1 = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 20;\nconst FunctionSetInputValue$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 21;\nconst FunctionReset$2 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 22;\n\nvar stateChangeTypes$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MenuKeyDownArrowDown: MenuKeyDownArrowDown,\n  MenuKeyDownArrowUp: MenuKeyDownArrowUp,\n  MenuKeyDownEscape: MenuKeyDownEscape,\n  MenuKeyDownHome: MenuKeyDownHome,\n  MenuKeyDownEnd: MenuKeyDownEnd,\n  MenuKeyDownEnter: MenuKeyDownEnter,\n  MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,\n  MenuKeyDownCharacter: MenuKeyDownCharacter,\n  MenuBlur: MenuBlur,\n  MenuMouseLeave: MenuMouseLeave$1,\n  ItemMouseMove: ItemMouseMove$1,\n  ItemClick: ItemClick$1,\n  ToggleButtonClick: ToggleButtonClick$1,\n  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,\n  FunctionToggleMenu: FunctionToggleMenu$1,\n  FunctionOpenMenu: FunctionOpenMenu$1,\n  FunctionCloseMenu: FunctionCloseMenu$1,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,\n  FunctionSelectItem: FunctionSelectItem$1,\n  FunctionSetInputValue: FunctionSetInputValue$1,\n  FunctionReset: FunctionReset$2\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftSelectReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick$1:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index]\n      };\n      break;\n\n    case ToggleButtonKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const itemIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(itemIndex >= 0 && {\n            selectedItem: props.items[itemIndex]\n          })\n        };\n      }\n      break;\n\n    case ToggleButtonKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case ToggleButtonKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case MenuKeyDownEnter:\n    case MenuKeyDownSpaceButton:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        ...(state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex]\n        })\n      };\n      break;\n\n    case MenuKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const highlightedIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.highlightedIndex,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(highlightedIndex >= 0 && {\n            highlightedIndex\n          })\n        };\n      }\n      break;\n\n    case MenuKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case MenuKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case FunctionSelectItem$1:\n      changes = {\n        selectedItem: action.selectedItem\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$2);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseSelect.stateChangeTypes = stateChangeTypes$2;\n\nfunction useSelect(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$2(userProps, useSelect); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$2,\n    ...userProps\n  };\n  const {\n    items,\n    scrollIntoView,\n    environment,\n    initialIsOpen,\n    defaultIsOpen,\n    itemToString,\n    getA11ySelectionMessage,\n    getA11yStatusMessage\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$2(props);\n  const [state, dispatch] = useControlledReducer$1(downshiftSelectReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element efs.\n\n  const toggleButtonRef = useRef(null);\n  const menuRef = useRef(null);\n  const itemRefs = useRef({}); // used not to trigger menu blur action in some scenarios.\n\n  const shouldBlurRef = useRef(true); // used to keep the inputValue clearTimeout object between renders.\n\n  const clearTimeoutRef = useRef(null); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef();\n  const isInitialMountRef = useRef(true); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Some utils.\n\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  }); // Sets cleanup for the keysSoFar callback, debounded after 500ms.\n\n  useEffect(() => {\n    // init the clean function here as we need access to dispatch.\n    clearTimeoutRef.current = debounce(outerDispatch => {\n      outerDispatch({\n        type: FunctionSetInputValue$1,\n        inputValue: ''\n      });\n    }, 500); // Cancel any pending debounced calls on mount\n\n    return () => {\n      clearTimeoutRef.current.cancel();\n    };\n  }, []); // Invokes the keysSoFar callback set up above.\n\n  useEffect(() => {\n    if (!inputValue) {\n      return;\n    }\n\n    clearTimeoutRef.current(dispatch);\n  }, [dispatch, inputValue]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  /* Controls the focus on the menu or the toggle button. */\n\n  useEffect(() => {\n    // Don't focus menu on first render.\n    if (isInitialMountRef.current) {\n      // Unless it was initialised as open.\n      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus menu on open.\n\n\n    if (isOpen) {\n      // istanbul ignore else\n      if (menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.\n\n\n    if (environment.document.activeElement === menuRef.current) {\n      // istanbul ignore else\n      if (toggleButtonRef.current) {\n        shouldBlurRef.current = false;\n        toggleButtonRef.current.focus();\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [isOpen]);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: MenuBlur\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]); // Event handler functions.\n\n  const toggleButtonKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]);\n  const menuKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    Home(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape() {\n      dispatch({\n        type: MenuKeyDownEscape\n      });\n    },\n\n    Enter(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnter\n      });\n    },\n\n    ' '(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownSpaceButton\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]); // Action functions.\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu$1\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu$1\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu$1\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex$1,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem$1,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$2\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue$1,\n      inputValue: newInputValue\n    });\n  }, [dispatch]); // Getter functions.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.toggleButtonId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      onKeyDown,\n      onBlur,\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    const latestState = latest.current.state;\n\n    const menuHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && menuKeyDownHandlers[key]) {\n        menuKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: MenuKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const menuHandleBlur = () => {\n      // if the blur was a result of selection, we don't trigger this action.\n      if (shouldBlurRef.current === false) {\n        shouldBlurRef.current = true;\n        return;\n      }\n\n      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;\n      /* istanbul ignore else */\n\n      if (shouldBlur) {\n        dispatch({\n          type: MenuBlur\n        });\n      }\n    };\n\n    const menuHandleMouseLeave = () => {\n      dispatch({\n        type: MenuMouseLeave$1\n      });\n    };\n\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      tabIndex: -1,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),\n      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),\n      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),\n      ...rest\n    };\n  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getToggleButtonProps = useCallback(function (_temp3, _temp4) {\n    let {\n      onClick,\n      onKeyDown,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      suppressRefError = false\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick$1\n      });\n    };\n\n    const toggleButtonHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && toggleButtonKeyDownHandlers[key]) {\n        toggleButtonKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: ToggleButtonKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const toggleProps = {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      'aria-haspopup': 'listbox',\n      'aria-expanded': latest.current.state.isOpen,\n      'aria-labelledby': `${elementIds.labelId} ${elementIds.toggleButtonId}`,\n      ...rest\n    };\n\n    if (!rest.disabled) {\n      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);\n      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);\n    }\n\n    setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);\n    return toggleProps;\n  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getItemProps = useCallback(function (_temp5) {\n    let {\n      item,\n      index,\n      onMouseMove,\n      onClick,\n      refKey = 'ref',\n      ref,\n      disabled,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    const {\n      state: latestState,\n      props: latestProps\n    } = latest.current;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove$1,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick$1,\n        index\n      });\n    };\n\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const itemProps = {\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      ...rest\n    };\n\n    if (!disabled) {\n      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);\n    }\n\n    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);\n    return itemProps;\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  return {\n    // prop getters.\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    selectItem,\n    reset,\n    setInputValue,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst InputKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_down__' : 0;\nconst InputKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_up__' : 1;\nconst InputKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__input_keydown_escape__' : 2;\nconst InputKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__input_keydown_home__' : 3;\nconst InputKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__input_keydown_end__' : 4;\nconst InputKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__input_keydown_enter__' : 5;\nconst InputChange = process.env.NODE_ENV !== \"production\" ? '__input_change__' : 6;\nconst InputBlur = process.env.NODE_ENV !== \"production\" ? '__input_blur__' : 7;\nconst MenuMouseLeave = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 8;\nconst ItemMouseMove = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 9;\nconst ItemClick = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 10;\nconst ToggleButtonClick = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 11;\nconst FunctionToggleMenu = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 12;\nconst FunctionOpenMenu = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 13;\nconst FunctionCloseMenu = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 14;\nconst FunctionSetHighlightedIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 15;\nconst FunctionSelectItem = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 16;\nconst FunctionSetInputValue = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 17;\nconst FunctionReset$1 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 18;\nconst ControlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__controlled_prop_updated_selected_item__' : 19;\n\nvar stateChangeTypes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  InputKeyDownArrowDown: InputKeyDownArrowDown,\n  InputKeyDownArrowUp: InputKeyDownArrowUp,\n  InputKeyDownEscape: InputKeyDownEscape,\n  InputKeyDownHome: InputKeyDownHome,\n  InputKeyDownEnd: InputKeyDownEnd,\n  InputKeyDownEnter: InputKeyDownEnter,\n  InputChange: InputChange,\n  InputBlur: InputBlur,\n  MenuMouseLeave: MenuMouseLeave,\n  ItemMouseMove: ItemMouseMove,\n  ItemClick: ItemClick,\n  ToggleButtonClick: ToggleButtonClick,\n  FunctionToggleMenu: FunctionToggleMenu,\n  FunctionOpenMenu: FunctionOpenMenu,\n  FunctionCloseMenu: FunctionCloseMenu,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,\n  FunctionSelectItem: FunctionSelectItem,\n  FunctionSetInputValue: FunctionSetInputValue,\n  FunctionReset: FunctionReset$1,\n  ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem\n});\n\nfunction getInitialState$1(props) {\n  const initialState = getInitialState$2(props);\n  const {\n    selectedItem\n  } = initialState;\n  let {\n    inputValue\n  } = initialState;\n\n  if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {\n    inputValue = props.itemToString(selectedItem);\n  }\n\n  return { ...initialState,\n    inputValue\n  };\n}\n\nconst propTypes$1 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  inputValue: PropTypes.string,\n  defaultInputValue: PropTypes.string,\n  initialInputValue: PropTypes.string,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  inputId: PropTypes.string,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * The useCombobox version of useControlledReducer, which also\n * checks if the controlled prop selectedItem changed between\n * renders. If so, it will also update inputValue with its\n * string equivalent. It uses the common useEnhancedReducer to\n * compute the rest of the state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useControlledReducer(reducer, initialState, props) {\n  const previousSelectedItemRef = useRef();\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props); // ToDo: if needed, make same approach as selectedItemChanged from Downshift.\n\n  useEffect(() => {\n    if (isControlledProp(props, 'selectedItem')) {\n      if (previousSelectedItemRef.current !== props.selectedItem) {\n        dispatch({\n          type: ControlledPropUpdatedSelectedItem,\n          inputValue: props.itemToString(props.selectedItem)\n        });\n      }\n\n      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;\n    }\n  });\n  return [getState(state, props), dispatch];\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validatePropTypes$1 = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$1 = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes$1, options, 'prop', caller.name);\n  };\n}\n\nconst defaultProps$1 = { ...defaultProps$3,\n  getA11yStatusMessage: getA11yStatusMessage$1,\n  circularNavigation: true\n};\n\n/* eslint-disable complexity */\n\nfunction downshiftUseComboboxReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index],\n        inputValue: props.itemToString(props.items[action.index])\n      };\n      break;\n\n    case InputKeyDownArrowDown:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownArrowUp:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownEnter:\n      changes = { ...(state.isOpen && state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex],\n          isOpen: getDefaultValue$1(props, 'isOpen'),\n          highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(!state.isOpen && {\n          selectedItem: null,\n          inputValue: ''\n        })\n      };\n      break;\n\n    case InputKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(state.highlightedIndex >= 0 && action.selectItem && {\n          selectedItem: props.items[state.highlightedIndex],\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputChange:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        inputValue: action.inputValue\n      };\n      break;\n\n    case FunctionSelectItem:\n      changes = {\n        selectedItem: action.selectedItem,\n        inputValue: props.itemToString(action.selectedItem)\n      };\n      break;\n\n    case ControlledPropUpdatedSelectedItem:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$1);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseCombobox.stateChangeTypes = stateChangeTypes$1;\n\nfunction useCombobox(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$1(userProps, useCombobox); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$1,\n    ...userProps\n  };\n  const {\n    initialIsOpen,\n    defaultIsOpen,\n    items,\n    scrollIntoView,\n    environment,\n    getA11yStatusMessage,\n    getA11ySelectionMessage,\n    itemToString\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$1(props);\n  const [state, dispatch] = useControlledReducer(downshiftUseComboboxReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element refs.\n\n  const menuRef = useRef(null);\n  const itemRefs = useRef({});\n  const inputRef = useRef(null);\n  const toggleButtonRef = useRef(null);\n  const comboboxRef = useRef(null);\n  const isInitialMountRef = useRef(true); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef(); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  });\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  }); // Focus the input on first render if required.\n\n  useEffect(() => {\n    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;\n\n    if (focusOnOpen && inputRef.current) {\n      inputRef.current.focus();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: InputBlur,\n      selectItem: false\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  /* Event handler functions */\n\n  const inputKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowDown,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowUp,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    Home(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape(event) {\n      const latestState = latest.current.state;\n\n      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {\n        event.preventDefault();\n        dispatch({\n          type: InputKeyDownEscape\n        });\n      }\n    },\n\n    Enter(event) {\n      const latestState = latest.current.state; // if closed or no highlighted index, do nothing.\n\n      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229 // if IME composing, wait for next Enter keydown event.\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnter,\n        getItemNodeFromIndex\n      });\n    }\n\n  }), [dispatch, latest, getItemNodeFromIndex]); // Getter props.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.inputId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {\n        dispatch({\n          type: MenuMouseLeave\n        });\n      }),\n      ...rest\n    };\n  }, [dispatch, setGetterPropCallInfo, elementIds]);\n  const getItemProps = useCallback(function (_temp3) {\n    let {\n      item,\n      index,\n      refKey = 'ref',\n      ref,\n      onMouseMove,\n      onMouseDown,\n      onClick,\n      onPress,\n      disabled,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    const {\n      props: latestProps,\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const onSelectKey = 'onClick';\n    const customClickHandler = onClick;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick,\n        index\n      });\n    };\n\n    const itemHandleMouseDown = e => e.preventDefault();\n\n    return {\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      ...(!disabled && {\n        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)\n      }),\n      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),\n      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown),\n      ...rest\n    };\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  const getToggleButtonProps = useCallback(function (_temp4) {\n    let {\n      onClick,\n      onPress,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick\n      });\n\n      if (!latest.current.state.isOpen && inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      tabIndex: -1,\n      ...(!rest.disabled && { ...({\n          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)\n        })\n      }),\n      ...rest\n    };\n  }, [dispatch, latest, elementIds]);\n  const getInputProps = useCallback(function (_temp5, _temp6) {\n    let {\n      onKeyDown,\n      onChange,\n      onInput,\n      onBlur,\n      onChangeText,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    let {\n      suppressRefError = false\n    } = _temp6 === void 0 ? {} : _temp6;\n    setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);\n    const latestState = latest.current.state;\n\n    const inputHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && inputKeyDownHandlers[key]) {\n        inputKeyDownHandlers[key](event);\n      }\n    };\n\n    const inputHandleChange = event => {\n      dispatch({\n        type: InputChange,\n        inputValue: event.target.value\n      });\n    };\n\n    const inputHandleBlur = () => {\n      /* istanbul ignore else */\n      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {\n        dispatch({\n          type: InputBlur,\n          selectItem: true\n        });\n      }\n    };\n    /* istanbul ignore next (preact) */\n\n\n    const onChangeKey = 'onChange';\n    let eventHandlers = {};\n\n    if (!rest.disabled) {\n      eventHandlers = {\n        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),\n        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),\n        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)\n      };\n    }\n\n    return {\n      [refKey]: handleRefs(ref, inputNode => {\n        inputRef.current = inputNode;\n      }),\n      id: elementIds.inputId,\n      'aria-autocomplete': 'list',\n      'aria-controls': elementIds.menuId,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      'aria-labelledby': elementIds.labelId,\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n      // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n      autoComplete: 'off',\n      value: latestState.inputValue,\n      ...eventHandlers,\n      ...rest\n    };\n  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);\n  const getComboboxProps = useCallback(function (_temp7, _temp8) {\n    let {\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp7 === void 0 ? {} : _temp7;\n    let {\n      suppressRefError = false\n    } = _temp8 === void 0 ? {} : _temp8;\n    setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);\n    return {\n      [refKey]: handleRefs(ref, comboboxNode => {\n        comboboxRef.current = comboboxNode;\n      }),\n      role: 'combobox',\n      'aria-haspopup': 'listbox',\n      'aria-owns': elementIds.menuId,\n      'aria-expanded': latest.current.state.isOpen,\n      ...rest\n    };\n  }, [latest, setGetterPropCallInfo, elementIds]); // returns\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue,\n      inputValue: newInputValue\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$1\n    });\n  }, [dispatch]);\n  return {\n    // prop getters.\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    getInputProps,\n    getComboboxProps,\n    getToggleButtonProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    setInputValue,\n    selectItem,\n    reset,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst defaultStateValues = {\n  activeIndex: -1,\n  selectedItems: []\n};\n/**\n * Returns the initial value for a state key in the following order:\n * 1. controlled prop, 2. initial prop, 3. default prop, 4. default\n * value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\nfunction getInitialValue(props, propKey) {\n  return getInitialValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Returns the default value for a state key in the following order:\n * 1. controlled prop, 2. default prop, 3. default value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\n\nfunction getDefaultValue(props, propKey) {\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Gets the initial state based on the provided props. It uses initial, default\n * and controlled props related to state in order to compute the initial value.\n *\n * @param {Object} props Props passed to the hook.\n * @returns {Object} The initial state.\n */\n\n\nfunction getInitialState(props) {\n  const activeIndex = getInitialValue(props, 'activeIndex');\n  const selectedItems = getInitialValue(props, 'selectedItems');\n  return {\n    activeIndex,\n    selectedItems\n  };\n}\n/**\n * Returns true if dropdown keydown operation is permitted. Should not be\n * allowed on keydown with modifier keys (ctrl, alt, shift, meta), on\n * input element with text content that is either highlighted or selection\n * cursor is not at the starting position.\n *\n * @param {KeyboardEvent} event The event from keydown.\n * @returns {boolean} Whether the operation is allowed.\n */\n\n\nfunction isKeyDownOperationPermitted(event) {\n  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n    return false;\n  }\n\n  const element = event.target;\n\n  if (element instanceof HTMLInputElement && // if element is a text input\n  element.value !== '' && ( // and we have text in it\n  // and cursor is either not at the start or is currently highlighting text.\n  element.selectionStart !== 0 || element.selectionEnd !== 0)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns a message to be added to aria-live region when item is removed.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11yRemovalMessage(selectionParameters) {\n  const {\n    removedSelectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;\n}\n\nconst propTypes = {\n  selectedItems: PropTypes.array,\n  initialSelectedItems: PropTypes.array,\n  defaultSelectedItems: PropTypes.array,\n  itemToString: PropTypes.func,\n  getA11yRemovalMessage: PropTypes.func,\n  stateReducer: PropTypes.func,\n  activeIndex: PropTypes.number,\n  initialActiveIndex: PropTypes.number,\n  defaultActiveIndex: PropTypes.number,\n  onActiveIndexChange: PropTypes.func,\n  onSelectedItemsChange: PropTypes.func,\n  keyNavigationNext: PropTypes.string,\n  keyNavigationPrevious: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\nconst defaultProps = {\n  itemToString: defaultProps$3.itemToString,\n  stateReducer: defaultProps$3.stateReducer,\n  environment: defaultProps$3.environment,\n  getA11yRemovalMessage,\n  keyNavigationNext: 'ArrowRight',\n  keyNavigationPrevious: 'ArrowLeft'\n}; // eslint-disable-next-line import/no-mutable-exports\n\nlet validatePropTypes = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes, options, 'prop', caller.name);\n  };\n}\n\nconst SelectedItemClick = process.env.NODE_ENV !== \"production\" ? '__selected_item_click__' : 0;\nconst SelectedItemKeyDownDelete = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_delete__' : 1;\nconst SelectedItemKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_backspace__' : 2;\nconst SelectedItemKeyDownNavigationNext = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_next__' : 3;\nconst SelectedItemKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_previous__' : 4;\nconst DropdownKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_navigation_previous__' : 5;\nconst DropdownKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_backspace__' : 6;\nconst DropdownClick = process.env.NODE_ENV !== \"production\" ? '__dropdown_click__' : 7;\nconst FunctionAddSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_add_selected_item__' : 8;\nconst FunctionRemoveSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_remove_selected_item__' : 9;\nconst FunctionSetSelectedItems = process.env.NODE_ENV !== \"production\" ? '__function_set_selected_items__' : 10;\nconst FunctionSetActiveIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_active_index__' : 11;\nconst FunctionReset = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 12;\n\nvar stateChangeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SelectedItemClick: SelectedItemClick,\n  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete,\n  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace,\n  SelectedItemKeyDownNavigationNext: SelectedItemKeyDownNavigationNext,\n  SelectedItemKeyDownNavigationPrevious: SelectedItemKeyDownNavigationPrevious,\n  DropdownKeyDownNavigationPrevious: DropdownKeyDownNavigationPrevious,\n  DropdownKeyDownBackspace: DropdownKeyDownBackspace,\n  DropdownClick: DropdownClick,\n  FunctionAddSelectedItem: FunctionAddSelectedItem,\n  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem,\n  FunctionSetSelectedItems: FunctionSetSelectedItems,\n  FunctionSetActiveIndex: FunctionSetActiveIndex,\n  FunctionReset: FunctionReset\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftMultipleSelectionReducer(state, action) {\n  const {\n    type,\n    index,\n    props,\n    selectedItem\n  } = action;\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  let changes;\n\n  switch (type) {\n    case SelectedItemClick:\n      changes = {\n        activeIndex: index\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationNext:\n      changes = {\n        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1\n      };\n      break;\n\n    case SelectedItemKeyDownBackspace:\n    case SelectedItemKeyDownDelete:\n      {\n        let newActiveIndex = activeIndex;\n\n        if (selectedItems.length === 1) {\n          newActiveIndex = -1;\n        } else if (activeIndex === selectedItems.length - 1) {\n          newActiveIndex = selectedItems.length - 2;\n        }\n\n        changes = {\n          selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],\n          ...{\n            activeIndex: newActiveIndex\n          }\n        };\n        break;\n      }\n\n    case DropdownKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: selectedItems.length - 1\n      };\n      break;\n\n    case DropdownKeyDownBackspace:\n      changes = {\n        selectedItems: selectedItems.slice(0, selectedItems.length - 1)\n      };\n      break;\n\n    case FunctionAddSelectedItem:\n      changes = {\n        selectedItems: [...selectedItems, selectedItem]\n      };\n      break;\n\n    case DropdownClick:\n      changes = {\n        activeIndex: -1\n      };\n      break;\n\n    case FunctionRemoveSelectedItem:\n      {\n        let newActiveIndex = activeIndex;\n        const selectedItemIndex = selectedItems.indexOf(selectedItem);\n\n        if (selectedItemIndex >= 0) {\n          if (selectedItems.length === 1) {\n            newActiveIndex = -1;\n          } else if (selectedItemIndex === selectedItems.length - 1) {\n            newActiveIndex = selectedItems.length - 2;\n          }\n\n          changes = {\n            selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],\n            activeIndex: newActiveIndex\n          };\n        }\n\n        break;\n      }\n\n    case FunctionSetSelectedItems:\n      {\n        const {\n          selectedItems: newSelectedItems\n        } = action;\n        changes = {\n          selectedItems: newSelectedItems\n        };\n        break;\n      }\n\n    case FunctionSetActiveIndex:\n      {\n        const {\n          activeIndex: newActiveIndex\n        } = action;\n        changes = {\n          activeIndex: newActiveIndex\n        };\n        break;\n      }\n\n    case FunctionReset:\n      changes = {\n        activeIndex: getDefaultValue(props, 'activeIndex'),\n        selectedItems: getDefaultValue(props, 'selectedItems')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n\nuseMultipleSelection.stateChangeTypes = stateChangeTypes;\n\nfunction useMultipleSelection(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes(userProps, useMultipleSelection); // Props defaults and destructuring.\n\n  const props = { ...defaultProps,\n    ...userProps\n  };\n  const {\n    getA11yRemovalMessage,\n    itemToString,\n    environment,\n    keyNavigationNext,\n    keyNavigationPrevious\n  } = props; // Reducer init.\n\n  const [state, dispatch] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);\n  const {\n    activeIndex,\n    selectedItems\n  } = state; // Refs.\n\n  const isInitialMountRef = useRef(true);\n  const dropdownRef = useRef(null);\n  const previousSelectedItemsRef = useRef(selectedItems);\n  const selectedItemRefs = useRef();\n  selectedItemRefs.current = [];\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Effects.\n\n  /* Sets a11y status message on changes in selectedItem. */\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (selectedItems.length < previousSelectedItemsRef.current.length) {\n      const removedSelectedItem = previousSelectedItemsRef.current.find(item => selectedItems.indexOf(item) < 0);\n      setStatus(getA11yRemovalMessage({\n        itemToString,\n        resultCount: selectedItems.length,\n        removedSelectedItem,\n        activeIndex,\n        activeSelectedItem: selectedItems[activeIndex]\n      }), environment.document);\n    }\n\n    previousSelectedItemsRef.current = selectedItems; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedItems.length]); // Sets focus on active item.\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (activeIndex === -1 && dropdownRef.current) {\n      dropdownRef.current.focus();\n    } else if (selectedItemRefs.current[activeIndex]) {\n      selectedItemRefs.current[activeIndex].focus();\n    }\n  }, [activeIndex]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getDropdownProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Event handler functions.\n\n  const selectedItemKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationPrevious\n      });\n    },\n\n    [keyNavigationNext]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationNext\n      });\n    },\n\n    Delete() {\n      dispatch({\n        type: SelectedItemKeyDownDelete\n      });\n    },\n\n    Backspace() {\n      dispatch({\n        type: SelectedItemKeyDownBackspace\n      });\n    }\n\n  }), [dispatch, keyNavigationNext, keyNavigationPrevious]);\n  const dropdownKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious](event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownNavigationPrevious\n        });\n      }\n    },\n\n    Backspace(event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownBackspace\n        });\n      }\n    }\n\n  }), [dispatch, keyNavigationPrevious]); // Getter props.\n\n  const getSelectedItemProps = useCallback(function (_temp) {\n    let {\n      refKey = 'ref',\n      ref,\n      onClick,\n      onKeyDown,\n      selectedItem,\n      index,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    const {\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, selectedItem, latestState.selectedItems);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either selectedItem or index in getSelectedItemProps!');\n    }\n\n    const selectedItemHandleClick = () => {\n      dispatch({\n        type: SelectedItemClick,\n        index\n      });\n    };\n\n    const selectedItemHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && selectedItemKeyDownHandlers[key]) {\n        selectedItemKeyDownHandlers[key](event);\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, selectedItemNode => {\n        if (selectedItemNode) {\n          selectedItemRefs.current.push(selectedItemNode);\n        }\n      }),\n      tabIndex: index === latestState.activeIndex ? 0 : -1,\n      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),\n      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),\n      ...rest\n    };\n  }, [dispatch, latest, selectedItemKeyDownHandlers]);\n  const getDropdownProps = useCallback(function (_temp2, _temp3) {\n    let {\n      refKey = 'ref',\n      ref,\n      onKeyDown,\n      onClick,\n      preventKeyAction = false,\n      ...rest\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      suppressRefError = false\n    } = _temp3 === void 0 ? {} : _temp3;\n    setGetterPropCallInfo('getDropdownProps', suppressRefError, refKey, dropdownRef);\n\n    const dropdownHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && dropdownKeyDownHandlers[key]) {\n        dropdownKeyDownHandlers[key](event);\n      }\n    };\n\n    const dropdownHandleClick = () => {\n      dispatch({\n        type: DropdownClick\n      });\n    };\n\n    return {\n      [refKey]: handleRefs(ref, dropdownNode => {\n        if (dropdownNode) {\n          dropdownRef.current = dropdownNode;\n        }\n      }),\n      ...(!preventKeyAction && {\n        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),\n        onClick: callAllEventHandlers(onClick, dropdownHandleClick)\n      }),\n      ...rest\n    };\n  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]); // returns\n\n  const addSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionAddSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const removeSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionRemoveSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const setSelectedItems = useCallback(newSelectedItems => {\n    dispatch({\n      type: FunctionSetSelectedItems,\n      selectedItems: newSelectedItems\n    });\n  }, [dispatch]);\n  const setActiveIndex = useCallback(newActiveIndex => {\n    dispatch({\n      type: FunctionSetActiveIndex,\n      activeIndex: newActiveIndex\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset\n    });\n  }, [dispatch]);\n  return {\n    getSelectedItemProps,\n    getDropdownProps,\n    addSelectedItem,\n    removeSelectedItem,\n    setSelectedItems,\n    setActiveIndex,\n    reset,\n    selectedItems,\n    activeIndex\n  };\n}\n\nexport { Downshift$1 as default, resetIdCounter, useCombobox, useMultipleSelection, useSelect };\n"],"names":["_defineProperties","target","props","i","descriptor","_createClass","Constructor","protoProps","staticProps","_extends","source","key","_inheritsLoose","subClass","superClass","_setPrototypeOf","o","p","_unsupportedIterableToArray","minLen","_arrayLikeToArray","n","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","useTrackRef","onRefChange","storedReference","useRef","setter","element","useMutableStore","initialState","state","useMemo","set","get","useEventSubscriptions","subscriptions","hasEventSubscriptions","removeAllEventSubscriptions","_iterator","_step","unsubscribe","addEventSubscription","unsubscriber","useIsomorphicLayoutEffect","useLayoutEffect","useEffect","useLastState","currentState","enabled","lastState","getPixelValue","value","limit","min","max","isSet","mergeRefs","_len","refs","_key","ref","getResizeObserver","environment","polyfill","findScrollContainers","result","_environment$getCompu","overflow","overflowX","overflowY","prop","createReferenceError","subject","useTrackElements","_ref","onChange","ResizeObserverPolyfill","overflowContainer","triggerOption","ResizeObserver","arrowRef","hasTriggerOption","_useMutableStore","_useEventSubscription","handleChange","useCallback","_get","layer","trigger","scrollContainers","closestScrollContainer","scrollOffsets","scrollLeft","scrollTop","scrollX","scrollY","borderOffsets","_environment$getCompu2","borderLeftWidth","borderTopWidth","addEventListeners","_get2","ignoredInitialCall","observerCallback","observer","_i","_arr","_i2","_arr2","_element","listenForScrollElements","_loop","resetWhenReferenceChangedWhileTracking","previous","next","layerRef","_get3","previousLayer","getScrollContainers","position","closestScrollContainerHasCorrectStyling","triggerRef","_get4","previousTrigger","triggerOptionParent","GroupContext","createContext","GroupProvider","children","registrations","handleRegister","registration","createElement","getShouldCloseAccordingToChildren","event","shouldCloseWhenClickedOutside","useGroup","_ref2","isOpen","onOutsideClick","onParentClose","possibleRegisterFn","useContext","clickedOnTrigger","clickedOnLayer","shouldCloseAccordingToChildren","_ref3","closeChild","isChild","shouldNotListen","handleClick","_ref4","PLACEMENT_TYPES","OPPOSITES","SideBase","opposite","isHorizontal","sizeProp","oppositeSizeProp","cssProp","oppositeCssProp","isCenter","isPush","_proto","side","createSide","recursive","BoundSide","Side","SIDES","BoundsOffsets","offsets","boundsOffsets","first","rest","boundsOffset","_iterator2","_step2","_this","_this2","sumOfPropertyValues","propertyValues","sum","propertyValue","boundsToObject","top","left","right","bottom","width","height","EMPTY","Bounds","bounds","options","_options","_options$withTransfor","withTransform","_options$environment","_options$withScrollba","withScrollbars","plain","boxSizing","borderLeft","borderRight","borderTop","borderBottom","paddingLeft","paddingRight","paddingTop","paddingBottom","boxWidth","boxHeight","scrollbarWidth","scrollbarHeight","_environment$document","scrollingElement","_ref2$clientWidth","_ref2$clientHeight","partialBoundsOrMergeFn","current","entries","_entries","_entries$_i","boundSide","child","mapper","boundSides","_boundSides","Placement","primary","secondary","subjectBounds","layerDimensions","dimensions","secondaryOffset","subjectsBounds","arrow","arrowOffsetBase","limitMin","limitMax","propertyA","propertyB","sec","triggerValue","arrowCompensation","layerBounds","container","_this$subjectsBounds","triggerHasBiggerWidth","triggerHasBiggerHeight","containerOffsets","substract","_Object$entries$map$f","_Object$entries$map$f2","_ref5","_ref6","a","b","mostNegativeSide","PlacementCenter","_Placement","_proto2","_this$subjectsBounds2","getNegativeOffsetBetweenLayerCenterAndTrigger","placement","arrowOffset","sizeProperty","sideA","sideB","offsetA","offsetB","STYLE_BASE","getArrowStyle","_extends2","triggerIsBigger","negativeOffset","primarySide","secondarySide","secondaryValue","Placements","placements","config","type","_type$split","getListOfPlacements","preferedPlacement","_Placements$getSidesF","preferredSide","placementFrom","list","_this$placements$map$","placementWithBiggestSurface","_this$config","auto","snap","placementsOnSameSide","currentPlacementHasHighestPriority","firstPlacementThatDoesNotFit","secondaryOffsetSide","factor","layerStyleBase","hasFullyDisappeared","suitablePlacement","styles","layerSide","SubjectsBounds","parent","getTriggerBounds","window","allContainers","scrollContainer","GLOBAL_CONTAINER","DEFAULT_OPTIONS","useLayer","_triggerBoundsRef$cur","_ref$isOpen","_ref$overflowContaine","_ref$environment","_ref$placement","_ref$possiblePlacemen","possiblePlacements","_ref$preferX","preferX","_ref$preferY","preferY","_ref$auto","_ref$snap","_ref$triggerOffset","triggerOffset","_ref$containerOffset","containerOffset","_ref$arrowOffset","_ref$container","_ref$layerDimensions","onDisappear","_useState","useState","setState","triggerBoundsRef","repositioningToken","handlePositioning","_Placements$create$re","hasDisappeared","newState","didStateChange","token","_useTrackElements","_useGroup","closeOnOutsideClickRefs","createPortal","getContainerElement","styleProps","_styleProps","DEFAULT_CONTAINER_ID","Status","c","d","e","f","g","h","k","l","m","q","r","u","v","w","x","y","z","A","B","C","D","E","F","G","H","I","reactIs_production_min","module","require$$0","t","s","W","V","R","T","O","X","Y","L","S","j","N","J","K","P","Q","U","Z","$","idCounter","noop","scrollIntoView","node","menuNode","computeScrollIntoView","el","isOrContainsNode","debounce","fn","time","timeoutId","cancel","wrapper","args","callAllEventHandlers","_len2","fns","_key2","_len3","_key3","handleRefs","_len4","_key4","generateId","getA11yStatusMessage$1","resultCount","previousResultCount","getState","prevState","isControlledProp","normalizeArrowKey","keyCode","getNextWrappingIndex","moveAmount","baseIndex","itemCount","getItemNodeFromIndex","circular","itemsLastIndex","newIndex","nonDisabledNewIndex","getNextNonDisabledIndex","currentElementNode","index","targetWithinDownshift","downshiftElements","checkActiveElement","contextNode","cleanupStatus","documentProp","getStatusDiv","setStatus","status","div","statusDiv","dropdownDefaultStateValues","callOnChangeProps","action","changes","invokeOnChangeHandler","handler","capitalizeString","stateReducer","getA11ySelectionMessage","selectionParameters","selectedItem","itemToStringLocal","updateA11yStatus","getA11yMessage","document","useElementIds","id","labelId","menuId","getItemId","toggleButtonId","inputId","getItemIndex","item","items","itemToString","isAcceptedCharacterKey","string","useLatestRef","val","useEnhancedReducer","reducer","prevStateRef","actionRef","enhancedReducer","dispatch","useReducer","propsRef","dispatchWithProps","useControlledReducer$1","defaultProps$3","getDefaultValue$1","propKey","defaultStateValues","defaultValue","getInitialValue$1","initialValue","getInitialState$2","highlightedIndex","inputValue","getHighlightedIndexOnOpen","offset","initialHighlightedIndex","defaultHighlightedIndex","useMouseAndTouchTracker","downshiftElementRefs","handleBlur","mouseAndTouchTrackersRef","onMouseDown","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","useGetterPropsCalledChecker","useA11yMessageSetter","dependencyArray","isInitialMount","useScrollIntoView","itemRefs","menuElement","scrollIntoViewProp","shouldScrollRef","useControlPropsValidator","downshiftCommonReducer","stateChangeTypes","getItemIndexByCharacterKey","_a","keysSoFar","lowerCasedKeysSoFar","offsetIndex","PropTypes","getA11yStatusMessage","defaultProps$2","__assign","validatePropTypes$2","MenuKeyDownArrowDown","MenuKeyDownArrowUp","MenuKeyDownEscape","MenuKeyDownHome","MenuKeyDownEnd","MenuKeyDownEnter","MenuKeyDownSpaceButton","MenuKeyDownCharacter","MenuBlur","MenuMouseLeave$1","ItemMouseMove$1","ItemClick$1","ToggleButtonClick$1","ToggleButtonKeyDownArrowDown","ToggleButtonKeyDownArrowUp","ToggleButtonKeyDownCharacter","FunctionToggleMenu$1","FunctionOpenMenu$1","FunctionCloseMenu$1","FunctionSetHighlightedIndex$1","FunctionSelectItem$1","FunctionSetInputValue$1","FunctionReset$2","stateChangeTypes$2","downshiftSelectReducer","shiftKey","lowercasedKey","itemIndex","useSelect","userProps","initialIsOpen","defaultIsOpen","toggleButtonRef","menuRef","shouldBlurRef","clearTimeoutRef","elementIds","previousResultCountRef","isInitialMountRef","latest","outerDispatch","setGetterPropCallInfo","toggleButtonKeyDownHandlers","menuKeyDownHandlers","toggleMenu","closeMenu","openMenu","setHighlightedIndex","newHighlightedIndex","selectItem","newSelectedItem","reset","setInputValue","newInputValue","getLabelProps","labelProps","getMenuProps","_temp","_temp2","onMouseLeave","refKey","onKeyDown","onBlur","latestState","menuHandleKeyDown","menuHandleBlur","menuHandleMouseLeave","getToggleButtonProps","_temp3","_temp4","onClick","toggleButtonHandleClick","toggleButtonHandleKeyDown","toggleProps","toggleButtonNode","getItemProps","_temp5","onMouseMove","disabled","latestProps","itemHandleMouseMove","itemHandleClick","itemProps","itemNode","getInitialValue","getDefaultValue","getInitialState","activeIndex","selectedItems","isKeyDownOperationPermitted","getA11yRemovalMessage","removedSelectedItem","defaultProps","SelectedItemClick","SelectedItemKeyDownDelete","SelectedItemKeyDownBackspace","SelectedItemKeyDownNavigationNext","SelectedItemKeyDownNavigationPrevious","DropdownKeyDownNavigationPrevious","DropdownKeyDownBackspace","DropdownClick","FunctionAddSelectedItem","FunctionRemoveSelectedItem","FunctionSetSelectedItems","FunctionSetActiveIndex","FunctionReset","downshiftMultipleSelectionReducer","newActiveIndex","selectedItemIndex","newSelectedItems","useMultipleSelection","keyNavigationNext","keyNavigationPrevious","dropdownRef","previousSelectedItemsRef","selectedItemRefs","selectedItemKeyDownHandlers","dropdownKeyDownHandlers","getSelectedItemProps","selectedItemHandleClick","selectedItemHandleKeyDown","selectedItemNode","getDropdownProps","preventKeyAction","dropdownHandleKeyDown","dropdownHandleClick","dropdownNode","addSelectedItem","removeSelectedItem","setSelectedItems","setActiveIndex"],"mappings":"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"}